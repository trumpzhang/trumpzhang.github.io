[{"categories":["Qt"],"contents":"@TOC\n一.Qt的简介 Qt 是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它既可以开发GUI程序，也可用于开发非GUI程序，比如控制台工具和服务器。基本上，Qt 同 Windows 平台上的 MFC，OWL，VCL，ATL 是同类型的东西。\n使用Qt有哪些优点：\n 优良的跨平台性 一次编写，处处运行 面向对象 模块化的设计 丰富的 API 良好的开发文档  使用Qt开发的著名程序有：\n Google Earth Opera(浏览器) VirtualBox(创建虚拟机) wps Office(著名办公软件)  二.Qt中的重要概念 1.信号与槽机制 用Java做过桌面程序的伙伴都知道，我们需要为按钮、文本输入框、窗体等各种组件添加事件监听器（鼠标监听器、键盘监听器）来与用户产生交互。在Qt中，信号与槽函数就负责交互任务。\n  信号(signal)   作用：发出一个信号，可被所有对象监听，该信号是没有目的的，就像校园里的广播一样，所有人都会听到。在Qt中，这也称为信号的广播机制，如果有对象对这个信号感兴趣，那么它可以使用connect函数来连接此信号，将这个信号(signal)与自己的一个槽（slot）绑定来进行处理。\n  槽(slot)   作用：接收到信号后要如何处理（进行什么动作），其本质是类的一个成员函数，和C++成员函数几乎无区别。可以为任意类型：public、protected、private，唯一区别在于：槽函数可以绑定信号，每当与槽函数绑定的信号被发射时，该槽函数将被触发调用。 connect()函数最常用的一般形式：\nconnect(sender, \u0026amp;Send::signal, receiver, \u0026amp;Receiver::slot) 可以解释为： sender:发送者 signal:信号 receiver:接收者 slot:动作\n举个例子，在Qt4中：\nconnect(button, SIGNAL(clicked()), \u0026amp;a, SLOT(quit())); 现在有一个名为button的按钮，一个名为a的窗口，connect函数将按钮的点击信号绑定在a的一个槽函数，那么当按钮button被点击后，a执行quit操作。\n2.Lambda表达式 在Qt5中，可以使用Lambda表达式来定义并创建匿名的函数对象，不过这是C++11引入的新特性，如果要使用Lambda表达式，必须在.pro文件中写入\nCONFIG += c++11 connect(button, \u0026amp;QPushButton::clicked, // = :把外部所有局部变量、类中所有成员以值传递方式 // this: 类中所有成员以值传递方式 // \u0026amp; : 把外部所有局部变量， 引用符号 [=]() { qDebug() \u0026lt;\u0026lt;\u0026quot; button is clicked\u0026quot;; } ); 三.使用Qt设计师快速开发 1. 环境搭建 我使用Qt官方提供的Qt 5.12.3 安装时会安装Qt Creator 4.9.0 这个IDE,数据库使用Mysql x64 5.6版本.\n（1）连接Mysql数据库  使用ODBC driver连接数据库，你需要先将驱动复制到Qt 安装目录下。 驱动位置一般在你的数据库安装目录下（例如）：  C:\\Program Files\\MySQL\\MySQL Server 5.6\\lib 复制上面目录下的 libmysql.dll文件到Qt安装目录的bin目录下：\nC:\\Qt\\Qt5.12.3\\5.12.3\\mingw73_64\\bin  测试连接数据库是否成功 打开Qt-\u0026gt;New Project-\u0026gt;Qt Widget Application-\u0026gt;项目名称-\u0026gt;mainWindow-\u0026gt;勾选创建界面 在demo1.pro 后添加sql ，并点击小锤子图标，作用是编译但不运行，编译添加的sql模块 打开mainWindow.cpp,添加以下头文件代码：  #include\u0026lt;QSqlDatabase\u0026gt; #include\u0026lt;QDebug\u0026gt; #include\u0026lt;QMessageBox\u0026gt; #include\u0026lt;QSqlError\u0026gt; #include\u0026lt;QSqlTableModel\u0026gt; #include\u0026lt;QSqlRecord\u0026gt; 编写连接数据库的代码\n#include \u0026quot;mainwindow.h\u0026quot; #include \u0026quot;ui_mainwindow.h\u0026quot; #include\u0026lt;QSqlDatabase\u0026gt; #include\u0026lt;QDebug\u0026gt; #include\u0026lt;QMessageBox\u0026gt; #include\u0026lt;QSqlError\u0026gt; #include\u0026lt;QSqlTableModel\u0026gt; #include\u0026lt;QSqlRecord\u0026gt; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) { ui-\u0026gt;setupUi(this); //连接数据库 QSqlDatabase db= QSqlDatabase::addDatabase(\u0026quot;QMYSQL\u0026quot;); //设置数据库 db.setHostName(\u0026quot;127.0.0.1\u0026quot;); db.setPort(3306); db.setDatabaseName(\u0026quot;book\u0026quot;); db.setUserName(\u0026quot;root\u0026quot;); db.setPassword(\u0026quot;123456\u0026quot;); //打开时数据库 if(!db.open() ) { qDebug()\u0026lt;\u0026lt;\u0026quot;连接失败\u0026quot;; } else { qDebug()\u0026lt;\u0026lt;\u0026quot;连接成功\u0026quot;; } } MainWindow::~MainWindow() { delete ui; } 点击“运行”按钮，查看控制台信息 如果连接不成功，可能会出现以下问题：\n Qt连接MySQL的时候提示“QSqlDatabase: QMYSQL driver not loaded”，  原因一：缺少文件 解决办法: 从 C:\\Program Files\\MySQL\\MySQL Server 5.6\\lib中将 libmysql.dll 文件复制C:\\Qt\\Qt5.12.3\\5.12.3\\mingw73_64\\bin中。运行程序\n原因二：Qt Creator与MySQL位数不统一 如果上面的方法试过了还是不行那么应该是你安装的MySQL和QT的位数不同，可以打开Mysql控制台 输入show variables like \u0026lsquo;%version_%'; 即可查看Mysql位数。\n解决办法： 查看Qt Creator的位数，若为32位，则去下载32位的 libmysql.dll（自行搜索），重新运行程序。\n2.设计你的窗口 我在book数据库中建立4张信息表，book(书籍表)、customer（客户表）、worker（职工表）、sale（销售信息表）\nQt遵循MVC的设计模式：\n M (model)模型层，一般存放持久数据，Headers文件夹下的 .h文件 V(view)视图层，将模型层中的数据显示出来，Forms文件夹下的 .ui 文件 C(controller)控制层，负责从视图读取数据，并向模型发送数据，Sources文件夹下的 .cpp 文件  （1）添加4个选项卡来切换信息的显示 打开demo1-\u0026gt;Forms-\u0026gt;mainwindow.ui （2）为图书选项卡添加TableView控件和一些功能按钮 （3）添加布局 （4）将数据库的表与QSqlTableModel绑定，再将QSqlTableModel放在TableView(控件)中显示 先在mainwindow.h中添加头文件，并在private下声明一个私有QSqlTableModel 的对象\n#ifndef MAINWINDOW_H #define MAINWINDOW_H #include \u0026lt;QMainWindow\u0026gt; #include\u0026lt;QSqlTableModel\u0026gt; namespace Ui { class MainWindow; } class MainWindow : public QMainWindow { Q_OBJECT public: explicit MainWindow(QWidget *parent = nullptr); ~MainWindow(); private slots: void on_pushButton_clicked(); private: Ui::MainWindow *ui; QSqlTableModel *bookModel; }; #endif // MAINWINDOW_H 在mainwindow.cpp中将表book与bookModel绑定，再将bookModel放在图书选项卡的tableView中显示\n#include \u0026quot;mainwindow.h\u0026quot; #include \u0026quot;ui_mainwindow.h\u0026quot; #include\u0026lt;QSqlDatabase\u0026gt; #include\u0026lt;QDebug\u0026gt; #include\u0026lt;QMessageBox\u0026gt; #include\u0026lt;QSqlError\u0026gt; #include\u0026lt;QSqlTableModel\u0026gt; #include\u0026lt;QSqlRecord\u0026gt; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) { ui-\u0026gt;setupUi(this); //连接数据库 QSqlDatabase db= QSqlDatabase::addDatabase(\u0026quot;QMYSQL\u0026quot;); //设置数据库 db.setHostName(\u0026quot;127.0.0.1\u0026quot;); db.setPort(3306); db.setDatabaseName(\u0026quot;book\u0026quot;); db.setUserName(\u0026quot;root\u0026quot;); db.setPassword(\u0026quot;123456\u0026quot;); //打开时数据库 if(!db.open() ) { qDebug()\u0026lt;\u0026lt;\u0026quot;连接失败\u0026quot;; } else { qDebug()\u0026lt;\u0026lt;\u0026quot;连接成功\u0026quot;; } bookModel=new QSqlTableModel();//为bookModel分配空间 bookModel-\u0026gt;setTable(\u0026quot;book\u0026quot;);//指定表 ，此处将book表与bookModel绑定 bookModel-\u0026gt;select();//显示表里所有数据 ui-\u0026gt;tableView_book-\u0026gt;setModel(bookModel);// 将bookModel放在tableView_book中 } MainWindow::~MainWindow() { delete ui; } 点击运行，查看效果 但是发现，表头没有改过来，并且表里的数据可以直接修改，并且修改后数据库里的数据也同时被修改了，所以还需要设置表头和编辑策略\nui-\u0026gt;tableView_book-\u0026gt;setModel(bookModel);// 将bookModel放在tableView_book中 //设置表头 bookModel-\u0026gt;setHeaderData(0,Qt::Horizontal,\u0026quot;图书编号\u0026quot;); bookModel-\u0026gt;setHeaderData(1,Qt::Horizontal,\u0026quot;书名\u0026quot;); bookModel-\u0026gt;setHeaderData(2,Qt::Horizontal,\u0026quot;作者\u0026quot;); bookModel-\u0026gt;setHeaderData(3,Qt::Horizontal,\u0026quot;版次\u0026quot;); bookModel-\u0026gt;setHeaderData(4,Qt::Horizontal,\u0026quot;单价（元）\u0026quot;); bookModel-\u0026gt;setHeaderData(5,Qt::Horizontal,\u0026quot;出版社\u0026quot;); bookModel-\u0026gt;setHeaderData(6,Qt::Horizontal,\u0026quot;所属类别\u0026quot;); //设置model的编辑策略 为 手动提交修改 bookModel-\u0026gt;setEditStrategy(QSqlTableModel::OnManualSubmit); （5）为按钮添加事件监听器 1.为添加按钮添加槽 右击添加按钮-\u0026gt;转到槽-\u0026gt;clicked()，鼠标单击时，按钮发出signal,由槽函数接受处理void MainWindow::on_pushButton_clicked() { //添加空记录 QSqlRecord record=bookModel-\u0026gt;record(); int row=bookModel-\u0026gt;rowCount(); bookModel-\u0026gt;insertRecord(row,record); } 无论是添加还是删除，点击确定后才会去执行sql语句，即提交事务 2.为删除按钮添加槽 右击删除按钮-\u0026gt;转到槽-\u0026gt;clicked()，处理代码如下\nvoid MainWindow::on_pushButton_2_clicked() { //获取选中的模型 QItemSelectionModel *smodel=ui-\u0026gt;tableView_book-\u0026gt;selectionModel(); //获取模型中的索引 QModelIndexList list=smodel-\u0026gt;selectedRows(); //删除所有选中的行 for(int i=0;i\u0026lt;list.size();i++) { bookModel-\u0026gt;removeRow(list.at(i).row()); } } 这样，当你在选中某行后，点击删除按钮，行的左侧会出现 ! 号，这是因为我设置了编辑策略为手动提交，即向数据库添加了事务，所以为确定添加槽 3.为确定按钮添加槽 右键 确定-\u0026gt;转到槽-\u0026gt;clicked()\nvoid MainWindow::on_pushButton_3_clicked() { bookModel-\u0026gt;submitAll(); } 5.为取消按钮添加槽\nvoid MainWindow::on_pushButton_4_clicked() { //取消完再提交一次 bookModel-\u0026gt;revertAll(); bookModel-\u0026gt;submitAll(); } 6.为查找按钮添加槽 此处设置了两个查询条件 void MainWindow::on_pushButton_6_clicked() { QString name=ui-\u0026gt;lineEdit_name-\u0026gt;text();//获取用户输入 QString id=ui-\u0026gt;lineEdit_id-\u0026gt;text(); //组包 %1为占位符，第一个参数,%2为第二个参数 QString str=QString(\u0026quot;name='%1' or id='%2' \u0026quot;).arg(name,id); //添加过滤器 bookModel-\u0026gt;setFilter(str); bookModel-\u0026gt;select(); } 6.为显示所有按钮添加槽\nvoid MainWindow::on_pushButton_5_clicked() { bookModel-\u0026gt;setTable(\u0026quot;book\u0026quot;);//重新关联表 bookModel-\u0026gt;select();//再次显示所有数据 } 3.美化窗口控件  为选项卡设置图标 修改字体大小，选择font-\u0026gt;14 去互联网找需要的图标，此处使用阿里巴巴矢量图标库的图标资源 下载好图标资源后，将它们放在一个image文件夹下,并将此image文件夹拷贝至项目根目录下 右键项目名 demo1-\u0026gt;Add New-\u0026gt;Qt-\u0026gt;Qt Resource File 填上文件名，先选择“添加前缀” ，只留下 / 即可，再选择添加文件 为选项卡添加图标：添加时需要图片的路径 右击img.qrc-\u0026gt;open in editor-\u0026gt;右击图片-\u0026gt;复制资源路径到剪切板  //添加图标 ui-\u0026gt;tabWidget-\u0026gt;setTabIcon(0,QIcon(\u0026quot;://image/book.png\u0026quot;)); ui-\u0026gt;tabWidget-\u0026gt;setTabIcon(1,QIcon(\u0026quot;://image/职工.png\u0026quot;)); ui-\u0026gt;tabWidget-\u0026gt;setTabIcon(2,QIcon(\u0026quot;://image/客户.png\u0026quot;)); ui-\u0026gt;tabWidget-\u0026gt;setTabIcon(3,QIcon(\u0026quot;://image/销售订单.png\u0026quot;)); ui-\u0026gt;tabWidget-\u0026gt;setIconSize(QSize(25,25)); 接着为按钮添加图标\n//按钮添加图标 ui-\u0026gt;pushButton-\u0026gt;setIcon(QIcon(\u0026quot;://image/新增.png\u0026quot;)); // ui-\u0026gt;pushButton-\u0026gt;setIconSize(QSize(25,25));//图标大小 ui-\u0026gt;pushButton_2-\u0026gt;setIcon(QIcon(\u0026quot;://image/删 除 .png\u0026quot;)); ui-\u0026gt;pushButton_3-\u0026gt;setIcon(QIcon(\u0026quot;://image/确定.png\u0026quot;)); ui-\u0026gt;pushButton_4-\u0026gt;setIcon(QIcon(\u0026quot;://image/取消.png\u0026quot;)); ui-\u0026gt;pushButton_6-\u0026gt;setIcon(QIcon(\u0026quot;://image/查找.png\u0026quot;)); ui-\u0026gt;pushButton_5-\u0026gt;setIcon(QIcon(\u0026quot;://image/所有.png\u0026quot;)); 效果 4.使用QCharts绘制图表实现数据可视化 官方推出QCharts后，Qt画图再也不用需要配置第三方的qcustomplot和qwt插件了，QCharts功能比两者都好，且易用安装和使用。 使用QCharts绘图，你必须在安装Qt时勾选QCharts模块（默认不勾选），否则不能使用QCharts. 此处以柱状图为例演示官方示例的使用： Qt欢迎页-\u0026gt;示例-\u0026gt;输入barmodelmapper 打开运行：下面将它用到自己的项目中，可以看到他有两个头文件和.cpp文件，分别是：CustomTableModel和TableWidget 从头文件可以看到它继承自QAbstractTableModel,所以我在项目中建立两个Qt Item Model文件，名字和示例一致 1.在demo1.pro中添加charts，并点击小锤子编译此模块 2.建立文件 （1）创建CustomTableModel： 右击项目名demo1-\u0026gt;Add New-\u0026gt;Qt -\u0026gt;Qt Item Model class Name:输入CustomTableModel（和示例保持一致） Base Class:选择QAbstractTableModel （2）创建TableWidget： 右击项目名demo1-\u0026gt;Add New-\u0026gt;Qt -\u0026gt;Qt Item Model class Name:TableWidget Base Class:选择QAbstractTableModel （3）将官方示例中customTableModel和TableWidget的头文件和.cpp文件内容直接复制到对应的建立好的2个头文件和cpp文件中\n3.修改main函数，看是否成功运行 向main函数中添加头文件“tablewidget.h”，并生成一个实例，运行该实例：\n#include \u0026quot;mainwindow.h\u0026quot; #include \u0026lt;QApplication\u0026gt; #include\u0026quot;tablewidget.h\u0026quot; int main(int argc, char *argv[]) { QApplication a(argc, argv); // MainWindow w; // w.show(); TableWidget t; t.show(); return a.exec(); } 效果如下： 在我们的项目中成功运行了该官方实例，下面让这个图显示我们数据库中的数据 以显示数据库表sale中的销售信息为例，统计sale表中2018年和2019年每个月书籍的总销售量。 因此，我修改了CustomTableModel.cpp和TableWidget.cpp的部分代码： CustomTableModel.cpp:\n#include \u0026quot;customtablemodel.h\u0026quot; #include \u0026lt;QtCore/QVector\u0026gt; #include \u0026lt;QtCore/QTime\u0026gt; #include \u0026lt;QtCore/QRect\u0026gt; #include \u0026lt;QtCore/QRandomGenerator\u0026gt; #include \u0026lt;QtGui/QColor\u0026gt; #include\u0026lt;QDebug\u0026gt; #include\u0026lt;QMessageBox\u0026gt; #include\u0026lt;QSqlError\u0026gt; #include\u0026lt;QSqlTableModel\u0026gt; #include\u0026lt;QSqlRecord\u0026gt; #include\u0026lt;QSqlDatabase\u0026gt; #include\u0026lt;QSqlQuery\u0026gt; CustomTableModel::CustomTableModel(QObject *parent) : QAbstractTableModel(parent) { //连接数据库 QSqlDatabase db= QSqlDatabase::addDatabase(\u0026quot;QMYSQL\u0026quot;); //设置数据库 db.setHostName(\u0026quot;127.0.0.1\u0026quot;); db.setPort(3306); db.setDatabaseName(\u0026quot;book\u0026quot;); db.setUserName(\u0026quot;root\u0026quot;); db.setPassword(\u0026quot;123456\u0026quot;); //打开时数据库 if(!db.open() ) { qDebug()\u0026lt;\u0026lt;\u0026quot;连接失败\u0026quot;; return; } else { qDebug()\u0026lt;\u0026lt;\u0026quot;连接成功\u0026quot;; } QSqlQuery query; ////// m_columnCount = 2; m_rowCount = 12; QString a[]={\u0026quot;2018\u0026quot;,\u0026quot;2019\u0026quot;}; // m_data for (int i = 0; i \u0026lt; m_rowCount; i++) { //类型为qreal的一维向量 QVector\u0026lt;qreal\u0026gt;* dataVec = new QVector\u0026lt;qreal\u0026gt;(m_columnCount); for (int k = 0; k \u0026lt; dataVec-\u0026gt;size(); k++) { // if (k % 2 == 0) // dataVec-\u0026gt;replace(k, i * 50 + QRandomGenerator::global()-\u0026gt;bounded(20)); // else // dataVec-\u0026gt;replace(k, QRandomGenerator::global()-\u0026gt;bounded(100)); //用YEAR、Month这两个数据库中内置函数，分别统计每月的书籍销售量 QString sql=QString(\u0026quot;select SUM(count) from sale where YEAR(saledate)='%1' and\u0026quot; \u0026quot; MONTH(saledate)='%2' \u0026quot;).arg(a[k],QString::number(i+1)); // qDebug()\u0026lt;\u0026lt;sql\u0026lt;\u0026lt;\u0026quot;\\n\u0026quot;; query.exec(sql); while(query.next()) { int count=query.value(0).toInt(); //销售量插入到dataVec dataVec-\u0026gt;replace(k,count); } } //向m_data追加dataVec m_data.append(dataVec); } } CustomTableModel::~CustomTableModel() { qDeleteAll(m_data); } int CustomTableModel::rowCount(const QModelIndex \u0026amp;parent) const { Q_UNUSED(parent) return m_data.count(); } int CustomTableModel::columnCount(const QModelIndex \u0026amp;parent) const { Q_UNUSED(parent) return m_columnCount; } QVariant CustomTableModel::headerData(int section, Qt::Orientation orientation, int role) const { if (role != Qt::DisplayRole) return QVariant(); if (orientation == Qt::Horizontal) return QString(\u0026quot;201%1\u0026quot;).arg(section+8); else return QString(\u0026quot;%1\u0026quot;).arg(section + 1); } QVariant CustomTableModel::data(const QModelIndex \u0026amp;index, int role) const { if (role == Qt::DisplayRole) { return m_data[index.row()]-\u0026gt;at(index.column()); } else if (role == Qt::EditRole) { return m_data[index.row()]-\u0026gt;at(index.column()); } else if (role == Qt::BackgroundRole) { for (const QRect \u0026amp;rect : m_mapping) { if (rect.contains(index.column(), index.row())) return QColor(m_mapping.key(rect)); } // cell not mapped return white color return QColor(Qt::white); } return QVariant(); } bool CustomTableModel::setData(const QModelIndex \u0026amp;index, const QVariant \u0026amp;value, int role) { if (index.isValid() \u0026amp;\u0026amp; role == Qt::EditRole) { m_data[index.row()]-\u0026gt;replace(index.column(), value.toDouble()); emit dataChanged(index, index); return true; } return false; } Qt::ItemFlags CustomTableModel::flags(const QModelIndex \u0026amp;index) const { return QAbstractItemModel::flags(index) | Qt::ItemIsEditable; } void CustomTableModel::addMapping(QString color, QRect area) { m_mapping.insertMulti(color, area); } TableWidget.cpp代码修改如下：\n#include \u0026quot;tablewidget.h\u0026quot; #include \u0026lt;QtWidgets/QGridLayout\u0026gt; #include \u0026lt;QtWidgets/QTableView\u0026gt; #include \u0026lt;QtCharts/QChart\u0026gt; #include \u0026lt;QtCharts/QChartView\u0026gt; #include \u0026lt;QtCharts/QLineSeries\u0026gt; #include \u0026lt;QtCharts/QVXYModelMapper\u0026gt; #include \u0026lt;QtCharts/QBarSeries\u0026gt; #include \u0026lt;QtCharts/QBarSet\u0026gt; #include \u0026lt;QtCharts/QVBarModelMapper\u0026gt; #include \u0026lt;QtWidgets/QHeaderView\u0026gt; #include \u0026lt;QtCharts/QBarCategoryAxis\u0026gt; #include \u0026lt;QtCharts/QValueAxis\u0026gt; #include\u0026lt;QDebug\u0026gt; QT_CHARTS_USE_NAMESPACE TableWidget::TableWidget(QWidget *parent) : QWidget(parent) { qDebug()\u0026lt;\u0026lt;\u0026quot;窗口已生成\u0026quot;; // create simple model for storing data // user's table data model //! [1] m_model = new CustomTableModel; //! [1] //! [2] // create table view and add model to it QTableView *tableView = new QTableView; tableView-\u0026gt;setModel(m_model); tableView-\u0026gt;setMinimumWidth(300); tableView-\u0026gt;horizontalHeader()-\u0026gt;setSectionResizeMode(QHeaderView::Stretch); tableView-\u0026gt;verticalHeader()-\u0026gt;setSectionResizeMode(QHeaderView::Stretch); m_model-\u0026gt;setParent(tableView); //! [2] //! [3] QChart *chart = new QChart; chart-\u0026gt;setAnimationOptions(QChart::AllAnimations); //! [3] // series 1 //! [4] QBarSeries *series = new QBarSeries; int first = 0; int count = 12; QVBarModelMapper *mapper = new QVBarModelMapper(this); mapper-\u0026gt;setFirstBarSetColumn(0); mapper-\u0026gt;setLastBarSetColumn(1); mapper-\u0026gt;setFirstRow(first); mapper-\u0026gt;setRowCount(count); mapper-\u0026gt;setSeries(series); mapper-\u0026gt;setModel(m_model); chart-\u0026gt;addSeries(series); //! [4] //! [5] // for storing color hex from the series QString seriesColorHex = \u0026quot;#000000\u0026quot;; // get the color of the series and use it for showing the mapped area QList\u0026lt;QBarSet *\u0026gt; barsets = series-\u0026gt;barSets(); for (int i = 0; i \u0026lt; barsets.count(); i++) { seriesColorHex = \u0026quot;#\u0026quot; + QString::number(barsets.at(i)-\u0026gt;brush().color().rgb(), 16).right(6).toUpper(); m_model-\u0026gt;addMapping(seriesColorHex, QRect(1 + i, first, 1, barsets.at(i)-\u0026gt;count())); } //! [5] //! [6] QStringList categories; //修改坐标字段 categories \u0026lt;\u0026lt; \u0026quot;1月\u0026quot; \u0026lt;\u0026lt; \u0026quot;2月\u0026quot; \u0026lt;\u0026lt; \u0026quot;3月\u0026quot; \u0026lt;\u0026lt; \u0026quot;4月\u0026quot; \u0026lt;\u0026lt;\u0026quot;5月\u0026quot;\u0026lt;\u0026lt;\u0026quot;6月\u0026quot;\u0026lt;\u0026lt;\u0026quot;7月\u0026quot; \u0026lt;\u0026lt;\u0026quot;8月\u0026quot;\u0026lt;\u0026lt;\u0026quot;9月\u0026quot;\u0026lt;\u0026lt;\u0026quot;10月\u0026quot;\u0026lt;\u0026lt;\u0026quot;11月\u0026quot;\u0026lt;\u0026lt;\u0026quot;12月\u0026quot;; QBarCategoryAxis *axisX = new QBarCategoryAxis(); axisX-\u0026gt;append(categories); chart-\u0026gt;addAxis(axisX, Qt::AlignBottom); series-\u0026gt;attachAxis(axisX); QValueAxis *axisY = new QValueAxis(); chart-\u0026gt;addAxis(axisY, Qt::AlignLeft); series-\u0026gt;attachAxis(axisY); //! [6] //! [7] QChartView *chartView = new QChartView(chart); chartView-\u0026gt;setRenderHint(QPainter::Antialiasing); chartView-\u0026gt;setMinimumSize(800, 600); //! [7] //! [8] // create main layout QGridLayout *mainLayout = new QGridLayout; mainLayout-\u0026gt;addWidget(tableView, 1, 0); mainLayout-\u0026gt;addWidget(chartView, 1, 1); mainLayout-\u0026gt;setColumnStretch(1, 1); mainLayout-\u0026gt;setColumnStretch(0, 0); setLayout(mainLayout); //! [8] } 运行后的柱状图变成了下面这样，可以看到，数据是从数据库读出（在sale表中插入测试数据即可测试） demo源码已上传至github:点我去下载https://github.com/HelloZzy23/bookManageClient\n","permalink":"https://trumpzhang.github.io/blog/qt/%E4%BD%BF%E7%94%A8qt5%E5%BC%80%E5%8F%91%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F/","tags":["Qt"],"title":"使用Qt5开发桌面程序"},{"categories":["Django"],"contents":"1.Django的简介 Django是一个基于MVC构造的框架。但是在Django中，控制器接受用户输入的部分由框架自行处理，所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MTV模式。它们各自的职责如下： |层次| 职责 | |\u0026ndash;|\u0026ndash;| |模型（Model），即数据存取层 |模型（Model），即数据存取层 | |模板(Template)，即表现层 |处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。 | |视图（View），即业务逻辑层 |存取模型及调取恰当模板的相关逻辑。模型与模板的桥梁。 |\nDjango里重要的概念有：\n 路由映射 视图函数 模板渲染 Django自带的ORM操作(对象关系映射)  需要学习Django基础的同学可以浏览以下网站（非常有用）： Django中文手册 自强学堂 Django基础教程 django中文网\n2.项目的设计思路 1.在线考试系统需求如下： （1）系统登录：验证登录用户的身份，根据用户身份进入不同的页面。 （2）学生管理：供管理员使用，用于维护学生基本信息。 （3）老师管理：供管理员使用，用于维护教师的基本信息。 （4）试题管理：供教师管理，用于维护题库。 （5）组卷：供教师使用，教师可以根据考试科目，从题库中选择一些符合条件的试题，形成一份试卷。为了方便教师组卷，应提供方便的查询功能，使教师能查询不同要求的试题。 （6）在线考试：供学生使用，根据学生的班级和登录时间显示应考科目的试卷内容。试卷完成提交或考试时间到，不再允许学生修改试卷；实现自动评阅，记录学生的考试成绩，并将评阅结果提供给学生。 （7）成绩统计：供教师使用，按照科目、班级等统计学生的考试成绩。 （8）成绩查询：供教师和学生使用，提供不同查询方式，使教师和学生可以按需查询考试成绩。\n2.设计思路 (1)确定角色 由需求分析看出，系统有三个基本角色，学生、教师、管理员。\n 管理员负责后台信息的维护 系统要能实现自动阅卷功能  (2)数据库表的设计 因此，我们至少需要如下几个表：\n 学生表 student 教师表 teacher 题库表 question（为了方便，题库中都为单项选择题） 试卷表 paper 学生成绩表 grade  设计完表，我们还需要确定表间的关系，是1对1(1:1)，1对多(1:n)，还是多对多(n:m)，这很重要，因为后面我们在models.py中创建表时，需要指出表间关系。 显然\n 学生表和成绩表，1个学生可参加多门考试，会有多个成绩，学生表和成绩表为1:n 教师表和试卷表，1个教师会发布多套试卷，但1套试卷只能由1位教师发布，教师表和试卷表为1:n 试卷表和题库表，1套试卷里包含多道题，题库里的每道题也可出现在多个试卷中，故试卷表和题库表为n:m  表的详细设计如下：（使用MindMaster绘制，有点丑，请忽略，重点写下自己的思考和思路）\n3.搭建你的开发环境 IDE使用PyCharm(profession版的) python 3.7, Django 2.1.0 数据库为关系数据库mysql 5.6\n为了更快的下载python模块，需要切换镜像源，我使用阿里云的镜像（还有很多镜像源），方法如下： 在 C:\\Users\\XXX(你的账户) 下建立 pip文件夹，在pip下建立 pip.ini文件，输入以下代码：\n[global] index-url = http://mirrors.aliyun.com/pypi/simple/ [install] trusted-host=mirrors.aliyun.com\n安装所需模块\n Django的安装： pip install django==2.1.0（请指定版本号，最新的Django需要数据库mysql5.6以上），你可以使用pip list来查看版本，使用 pip uninstall django 来卸载django模块 安装mysql数据库驱动 pip install pymysql 配置好后建立项目  (1) 在PyCharm中建立Django项目 图1 建立项目 此处没有使用虚拟环境，你也可以选择 “New environment using”选项来创建一个虚拟环境（可以避免多个项目使用不同模块的版本时发生冲突）\n(2)创建app Tools-\u0026gt;Run manage.py task\n在控制台输入 startapp student，创建一个student app, 之后需要将student app配置在项目的settings.py中，由于我的前台需要用到css、BootStrap、一些图片等文件，所以我在项目下建立static文件夹，并将其路径配置在settings.py文件中。整体目录如下： （3）settings.py文件的配置 配置settings.py文件配置如下，请看注释\nINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'student',#将建立的app名称加入Installed_APPs中 ] MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] ROOT_URLCONF = 'onlineExam.urls' TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')] , 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] WSGI_APPLICATION = 'onlineExam.wsgi.application' # Database # https://docs.djangoproject.com/en/2.1/ref/settings/#databases #配置mysql数据库 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'exam',#使用数据库的名称 'USER':'root',#用户名 'PASSWORD':'123456',#密码 'HOST':'127.0.0.1',#地址 'PORT':'3306'#端口号 } } # Password validation # https://docs.djangoproject.com/en/2.1/ref/settings/#auth-password-validators AUTH_PASSWORD_VALIDATORS = [ { 'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', }, { 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', }, { 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', }, { 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', }, ] # Internationalization # https://docs.djangoproject.com/en/2.1/topics/i18n/ #修改语言为中文 LANGUAGE_CODE = 'zh-hans' #修改时区为shanghai TIME_ZONE = 'Asia/Shanghai' USE_I18N = True USE_L10N = True USE_TZ = True # Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/2.1/howto/static-files/ #添加static文件夹 STATIC_URL = '/static/' STATICFILES_DIRS=[ os.path.join(BASE_DIR,'static'), ] 需要注意的地方有：\n INSTALLED_APPS 添加了新建的student app DATABASES 配置你的数据库参数 MIDDLEWARE 注释掉了 # \u0026lsquo;django.middleware.csrf.CsrfViewMiddleware'这一行 STATICFILES_DIRS 添加新建的static文件夹  （4）在__init___.py文件添加mysql的驱动模块\nimport pymysql pymysql.install_as_MySQLdb() 4.分模块详细设计 （1）建表 在student下的models.py中建表\nfrom django.db import models # Create your models here. # 为性别,学院 指定备选字段 SEX=( ('男','男'), ('女','女'), ) DEPT=( ('计算机与通信学院','计算机与通信学院'), ('电气与自动化学院','电气与自动化学院'), ('外国语学院','外国语学院'), ('理学院','理学院'), ) class Student(models.Model): id=models.CharField('学号',max_length=20,primary_key=True) name=models.CharField('姓名',max_length=20) sex=models.CharField('性别',max_length=4,choices=SEX,default='男') dept=models.CharField('学院',max_length=20,choices=DEPT,default=None) major=models.CharField('专业',max_length=20,default=None) password=models.CharField('密码',max_length=20,default='111') email=models.EmailField('邮箱',default=None) birth=models.DateField('出生日期') class Meta: db_table='student' verbose_name='学生' verbose_name_plural=verbose_name def __str__(self): return self.id; class Teacher(models.Model): id=models.CharField(\u0026quot;教工号\u0026quot;,max_length=20,primary_key=True) name=models.CharField('姓名',max_length=20) sex=models.CharField('性别',max_length=4,choices=SEX,default='男') dept=models.CharField('学院',max_length=20,choices=DEPT,default=None) email=models.EmailField('邮箱',default=None) password=models.CharField('密码',max_length=20,default='000000') birth=models.DateField('出生日期') class Meta: db_table='teacher' verbose_name='教师' verbose_name_plural=verbose_name def __str__(self): return self.name; class Question(models.Model): ANSWER=( ('A','A'), ('B','B'), ('C','C'), ('D','D'), ) LEVEL={ ('1','easy'), ('2','general'), ('3','difficult'), } id = models.AutoField(primary_key=True) subject = models.CharField('科目', max_length=20) title = models.TextField('题目') optionA=models.CharField('A选项',max_length=30) optionB=models.CharField('B选项',max_length=30) optionC=models.CharField('C选项',max_length=30) optionD=models.CharField('D选项',max_length=30) answer=models.CharField('答案',max_length=10,choices=ANSWER) level=models.CharField('等级',max_length=10,choices=LEVEL) score=models.IntegerField('分数',default=1) class Meta: db_table='question' verbose_name='单项选择题库' verbose_name_plural=verbose_name def __str__(self): return '\u0026lt;%s:%s\u0026gt;'%(self.subject,self.title); class Paper(models.Model): #题号pid 和题库为多对多的关系 pid=models.ManyToManyField(Question)#多对多 tid=models.ForeignKey(Teacher,on_delete=models.CASCADE)#添加外键 subject=models.CharField('科目',max_length=20,default='') major=models.CharField('考卷适用专业',max_length=20) examtime=models.DateTimeField() class Meta: db_table='paper' verbose_name='试卷' verbose_name_plural=verbose_name def __str__(self): return self.major; class Grade(models.Model): sid=models.ForeignKey(Student,on_delete=models.CASCADE,default='')#添加外键 subject=models.CharField('科目',max_length=20,default='') grade=models.IntegerField() def __str__(self): return '\u0026lt;%s:%s\u0026gt;'%(self.sid,self.grade); class Meta: db_table='grade' verbose_name='成绩' verbose_name_plural=verbose_name (2)将模型映射到mysql数据库中，很简单，打开 Run manage.py Task,输入迁移命令 先输入makemigrate命令，作用是生成sql文件（create table student(id,sex,\u0026hellip;.) ），执行后可在student-\u0026gt; migrations下看到执行结果 再输入migrate命令，执行makemigrate生成的sql语句，表就建好了，你可以使用navicat或workBench等工具看到Django为我们建好的表 （2）创建管理员 继续输入createsuperuser命令创建管理员，以便登陆后台 （3）创建模板 在templates中建立index.html模板，作为考试系统首页.(可去官网下载BootStrap、JQuery) 在头文件里引入时注意顺序，jquery须在bootstrap.min.js之前引入\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1\u0026quot;\u0026gt; \u0026lt;link href=\u0026quot;../static/bootstrap-4.3.1-dist/css/bootstrap.min.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;!-- 必须在引入bootstarp.js之前引入 --\u0026gt; \u0026lt;script src=\u0026quot;../static/jquery-3.3.1.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;../static/bootstrap-4.3.1-dist/js/bootstrap.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026quot;../static/css/index.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;title\u0026gt;在线考试系统\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;nav class=\u0026quot;navbar navbar-expand-sm bg-light navbar-light \u0026quot;\u0026gt; \u0026lt;ul class=\u0026quot;navbar-nav\u0026quot;\u0026gt; \u0026lt;li class=\u0026quot;nav-item\u0026quot;\u0026gt; \u0026lt;a class=\u0026quot;nav-link\u0026quot; href=\u0026quot;/toIndex/\u0026quot;\u0026gt;\u0026lt;h3\u0026gt;在线考试系统 首页\u0026lt;/h3\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;button data-target=\u0026quot;#stuModal\u0026quot; data-toggle=\u0026quot;modal\u0026quot; class=\u0026quot;btn btn-primary\u0026quot;\u0026gt;学生登陆\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;button data-target=\u0026quot;#teaModal\u0026quot; data-toggle=\u0026quot;modal\u0026quot; class=\u0026quot;btn btn-primary\u0026quot;\u0026gt;教师登陆\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;nav-item\u0026quot;\u0026gt; \u0026lt;a class=\u0026quot;nav-link\u0026quot; href=\u0026quot;/admin\u0026quot;\u0026gt;管理员\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li style=\u0026quot;position: fixed;right: 70px; font-size: 40px;color: #9fcdff\u0026quot;\u0026gt;{{ student.name }}{{ message }}\u0026lt;/li\u0026gt; \u0026lt;a href=\u0026quot;/logout/\u0026quot;\u0026gt;\u0026lt;li style=\u0026quot;position: fixed;right: 20px; font-size: 20px;top:22px;color:#cc1313\u0026quot;\u0026gt;退出\u0026lt;/li\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- Nav pills --\u0026gt; \u0026lt;ul class=\u0026quot;nav nav-pills\u0026quot; role=\u0026quot;tablist\u0026quot;\u0026gt; \u0026lt;li class=\u0026quot;nav-item\u0026quot;\u0026gt; \u0026lt;a class=\u0026quot;nav-link active\u0026quot; data-toggle=\u0026quot;pill\u0026quot; href=\u0026quot;#home\u0026quot;\u0026gt;个人信息\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;nav-item\u0026quot;\u0026gt; \u0026lt;a class=\u0026quot;nav-link\u0026quot; data-toggle=\u0026quot;pill\u0026quot; href=\u0026quot;#menu1\u0026quot;\u0026gt;考试信息\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;nav-item\u0026quot;\u0026gt; \u0026lt;a class=\u0026quot;nav-link\u0026quot; data-toggle=\u0026quot;pill\u0026quot; href=\u0026quot;#menu2\u0026quot;\u0026gt;成绩查询\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;!-- Tab panes --\u0026gt; \u0026lt;div class=\u0026quot;tab-content\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;home\u0026quot; class=\u0026quot;container tab-pane active\u0026quot;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;h3\u0026gt;个人信息\u0026lt;/h3\u0026gt; \u0026lt;table class=\u0026quot;table\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;属性\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;信息\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;学号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.id }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-primary\u0026quot;\u0026gt; \u0026lt;td\u0026gt;姓名\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.name }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-success\u0026quot;\u0026gt; \u0026lt;td\u0026gt;性别\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.sex }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-danger\u0026quot;\u0026gt; \u0026lt;td\u0026gt;学院\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.dept }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-success\u0026quot;\u0026gt; \u0026lt;td\u0026gt;专业\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.major }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-warning\u0026quot;\u0026gt; \u0026lt;td\u0026gt;邮箱地址\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.email }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-active\u0026quot;\u0026gt; \u0026lt;td\u0026gt;出生日期\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.birth }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;menu1\u0026quot; class=\u0026quot;container tab-pane fade\u0026quot;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;h3\u0026gt;考试信息\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;table class=\u0026quot;table\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;学号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;考试科目\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;考试时间\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {# 遍历字典 paper #} {% for paper1 in paper %} \u0026lt;tr class=\u0026quot;table-info\u0026quot;\u0026gt; \u0026lt;td\u0026gt;{{ student.id }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.name }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ paper1.subject }}{{ paper2.subject }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ paper1.examtime }} {{ paper2.examtime }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;/startExam/?sid={{ student.id }}\u0026amp;subject={{ paper1.subject }}\u0026quot;\u0026gt; \u0026lt;button class=\u0026quot;btn btn-primary\u0026quot; id=\u0026quot;toExam+{{ paper1.subject }}\u0026quot;\u0026gt;开始考试\u0026lt;/button\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {% endfor %} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;menu2\u0026quot; class=\u0026quot;container tab-pane fade\u0026quot;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;h3\u0026gt;考试成绩\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;table class=\u0026quot;table\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;科目\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;成绩\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {% for grade1 in grade %} \u0026lt;tr class=\u0026quot;table-primary\u0026quot;\u0026gt; \u0026lt;td\u0026gt;{{ student.name }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ grade1.subject }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ grade1.grade }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {% endfor %} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {#学生登录的模态对话框#} \u0026lt;div class=\u0026quot;modal fade\u0026quot; tabindex=\u0026quot;-1\u0026quot; role=\u0026quot;dialog\u0026quot; id=\u0026quot;stuModal\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;modal-dialog\u0026quot; role=\u0026quot;document\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;modal-content\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;modal-header\u0026quot;\u0026gt; \u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;close\u0026quot; data-dismiss=\u0026quot;modal\u0026quot; aria-label=\u0026quot;Close\u0026quot;\u0026gt; \u0026lt;span aria-hidden=\u0026quot;true\u0026quot;\u0026gt;\u0026amp;times;\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;h4 class=\u0026quot;modal-title\u0026quot;\u0026gt;学生登陆\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form class=\u0026quot;form-horizontal\u0026quot; action=\u0026quot;/studentLogin/\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;modal-body\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label class=\u0026quot;col-sm-3 control-label\u0026quot;\u0026gt;学生学号\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026quot;col-sm-9\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; name=\u0026quot;id\u0026quot; placeholder=\u0026quot;输入学号\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label for=\u0026quot;addr\u0026quot; class=\u0026quot;col-sm-3 control-label\u0026quot;\u0026gt;密码\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026quot;col-sm-9\u0026quot;\u0026gt; \u0026lt;!-- \u0026lt;textarea id=\u0026quot;addr\u0026quot; class=\u0026quot;form-control\u0026quot; rows=\u0026quot;3\u0026quot;\u0026gt;\u0026lt;/textarea\u0026gt; --\u0026gt; \u0026lt;input type=\u0026quot;password\u0026quot; class=\u0026quot;form-control\u0026quot; name=\u0026quot;password\u0026quot; placeholder=\u0026quot;输入密码\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;modal-footer\u0026quot;\u0026gt; \u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;btn btn-default\u0026quot; data-dismiss=\u0026quot;modal\u0026quot;\u0026gt;取消\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot; class=\u0026quot;btn btn-primary\u0026quot;\u0026gt;登陆\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- /.modal-content --\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- /.modal-dialog --\u0026gt; \u0026lt;/div\u0026gt; {#老师登录的模态对话框#} \u0026lt;div class=\u0026quot;modal fade\u0026quot; tabindex=\u0026quot;-1\u0026quot; role=\u0026quot;dialog\u0026quot; id=\u0026quot;teaModal\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;modal-dialog\u0026quot; role=\u0026quot;document\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;modal-content\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;modal-header\u0026quot;\u0026gt; \u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;close\u0026quot; data-dismiss=\u0026quot;modal\u0026quot; aria-label=\u0026quot;Close\u0026quot;\u0026gt; \u0026lt;span aria-hidden=\u0026quot;true\u0026quot;\u0026gt;\u0026amp;times;\u0026lt;/span\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;h4 class=\u0026quot;modal-title\u0026quot;\u0026gt;教师登陆\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form class=\u0026quot;form-horizontal\u0026quot; action=\u0026quot;/teacherLogin/\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;modal-body\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label for=\u0026quot;inputEmail3\u0026quot; class=\u0026quot;col-sm-3 control-label\u0026quot;\u0026gt;教师工号\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026quot;col-sm-9\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; class=\u0026quot;form-control\u0026quot; name=\u0026quot;id\u0026quot; placeholder=\u0026quot;输入学号\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;form-group\u0026quot;\u0026gt; \u0026lt;label for=\u0026quot;addr\u0026quot; class=\u0026quot;col-sm-3 control-label\u0026quot;\u0026gt;密码\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026quot;col-sm-9\u0026quot;\u0026gt; \u0026lt;!-- \u0026lt;textarea id=\u0026quot;addr\u0026quot; class=\u0026quot;form-control\u0026quot; rows=\u0026quot;3\u0026quot;\u0026gt;\u0026lt;/textarea\u0026gt; --\u0026gt; \u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;password\u0026quot; placeholder=\u0026quot;输入密码\u0026quot; class=\u0026quot;form-control\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;modal-footer\u0026quot;\u0026gt; \u0026lt;button type=\u0026quot;button\u0026quot; class=\u0026quot;btn btn-default\u0026quot; data-dismiss=\u0026quot;modal\u0026quot;\u0026gt;取消\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot; class=\u0026quot;btn btn-primary\u0026quot;\u0026gt;登陆\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- /.modal-content --\u0026gt; \u0026lt;/div\u0026gt;\u0026lt;!-- /.modal-dialog --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; $(\u0026quot;#toExam+{{ paper1.subject }}\u0026quot;).click(function () { }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Django使用{{ }}来使用后台传来的数据 (4)创建视图函数 在student-\u0026gt;views.py中创建进入首页的视图函数index()\nfrom django.shortcuts import render,redirect from student import models from django.http import HttpResponse from django.contrib.auth import logout # Create your views here. def index(request): return render(request,'index.html') 将视图函数配置在路由中，打开项目的urls.py文件\nfrom django.contrib import admin from django.urls import path from django.conf.urls import url from student import views urlpatterns = [ #管理员登陆 path('admin/', admin.site.urls), #默认访问首页 url(r'^$',views.index), ] r表示使用正则表达式解析url地址，^表示开始，$表示结束，views.index表示调用视图函数index （5）启动服务器（可以看到效果了） 两种方式启动服务器：执行runserver命令，或点击绿色小图标 点击网址，默认8000端口，成功后如下图\n我们还需要定制自己的后台，在student-\u0026gt;admin.py中注册各模块\nfrom django.contrib import admin from .models import Student,Teacher,Paper,Question,Grade # Register your models here. # 修改名称 admin.site.site_header='在线考试系统后台' admin.site.site_title='在线考试系统' @admin.register(Student) class StudentAdmin(admin.ModelAdmin): list_display = ('id','name','sex','dept','major','password','email','birth')# 要显示哪些信息 list_display_links = ('id','name')#点击哪些信息可以进入编辑页面 search_fields = ['name','dept','major','birth'] #指定要搜索的字段，将会出现一个搜索框让管理员搜索关键词 list_filter =['name','dept','major','birth']#指定列表过滤器，右边将会出现一个快捷的过滤选项 对其他4个model注册后台\n@admin.register(Teacher) class TeacherAdmin(admin.ModelAdmin): list_display = ('id', 'name', 'sex', 'dept', 'password', 'email', 'birth') list_display_links = ('id', 'name') search_fields = ['name', 'dept', 'birth'] list_filter = ['name','dept'] @admin.register(Question) class QuestionAdmin(admin.ModelAdmin): list_display = ('id','subject','title','optionA','optionB','optionC','optionD','answer','level','score') 刷新，点击首页管理员超链接，进入后台，使用前边创建的superuser账户和密码登陆 进入后台 使用后台添加学生信息 （6）实现学生的登陆 这里需要用到Django内置的ORM模块，不在赘述，需要的同学看前边网站入门。\n 在views.py中创建studentLogin函数 学生登陆的form表单将学生输入的学号（id）,密码（password）通过post方式提交给服务器，所以视图函数先接受表单参数，判断用户名和密码与数据库是否一致，若一致，则登陆成功。 登陆成功后，我需要发送至少三条信息给index.html, （1）该学生的基本信息 （2）该学生考试信息，可通过该学生的专业名称在试卷表中查到有哪些要进行的考试 （3）该学生的考试成绩信息，可通过学生的学号在paper表中查询 代码如下：  def studentLogin(request): if request.method=='POST': # 获取表单信息 stuId=request.POST.get('id') password=request.POST.get('password') print(\u0026quot;id\u0026quot;,stuId,\u0026quot;password\u0026quot;,password) # 通过学号获取该学生实体 student=models.Student.objects.get(id=stuId) print(student) if password==student.password: #登录成功 #查询考试信息 paper=models.Paper.objects.filter(major=student.major) #查询成绩信息 grade=models.Grade.objects.filter(sid=student.id) # 渲染index模板 return render(request,'index.html',{'student':student,'paper':paper,'grade':grade}) else:return render(request,'index.html',{'message':'密码不正确'}) （7）模板的渲染（数据的显示） 登陆成功后，发送三个字典数据给index，index模板使用{{ }}、for等模板语句渲染\n\u0026lt;div class=\u0026quot;tab-content\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;home\u0026quot; class=\u0026quot;container tab-pane active\u0026quot;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;h3\u0026gt;个人信息\u0026lt;/h3\u0026gt; \u0026lt;table class=\u0026quot;table\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;属性\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;信息\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;学号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.id }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-primary\u0026quot;\u0026gt; \u0026lt;td\u0026gt;姓名\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.name }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-success\u0026quot;\u0026gt; \u0026lt;td\u0026gt;性别\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.sex }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-danger\u0026quot;\u0026gt; \u0026lt;td\u0026gt;学院\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.dept }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-success\u0026quot;\u0026gt; \u0026lt;td\u0026gt;专业\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.major }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-warning\u0026quot;\u0026gt; \u0026lt;td\u0026gt;邮箱地址\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.email }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr class=\u0026quot;table-active\u0026quot;\u0026gt; \u0026lt;td\u0026gt;出生日期\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.birth }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;menu1\u0026quot; class=\u0026quot;container tab-pane fade\u0026quot;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;h3\u0026gt;考试信息\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;table class=\u0026quot;table\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;学号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;考试科目\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;考试时间\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {# 遍历字典 paper #} {% for paper1 in paper %} \u0026lt;tr class=\u0026quot;table-info\u0026quot;\u0026gt; \u0026lt;td\u0026gt;{{ student.id }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ student.name }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ paper1.subject }}{{ paper2.subject }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ paper1.examtime }} {{ paper2.examtime }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href=\u0026quot;/startExam/?sid={{ student.id }}\u0026amp;subject={{ paper1.subject }}\u0026quot;\u0026gt; \u0026lt;button class=\u0026quot;btn btn-primary\u0026quot; id=\u0026quot;toExam+{{ paper1.subject }}\u0026quot;\u0026gt;开始考试\u0026lt;/button\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {% endfor %} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;menu2\u0026quot; class=\u0026quot;container tab-pane fade\u0026quot;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;h3\u0026gt;考试成绩\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;table class=\u0026quot;table\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;科目\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;成绩\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {% for grade1 in grade %} \u0026lt;tr class=\u0026quot;table-primary\u0026quot;\u0026gt; \u0026lt;td\u0026gt;{{ student.name }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ grade1.subject }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ grade1.grade }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {% endfor %} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; （8）教师登陆同上，学生在线考试和系统自动阅卷怎么实现呢？我是这样做的\n 学生登陆成功后，点击\u0026quot;开始考试\u0026quot;按钮，按钮将两个请求信息发送到服务器，自己的学号和试卷的科目。 startExam视图函数接收到学号和试卷的科目，找到试卷信息发送给另一模板（exam.html）渲染 因此，建立继续建立exam.html模板和startExam视图函数  def startExam(request): sid = request.GET.get('sid') subject1=request.GET.get('subject') #得到学生信息 student=models.Student.objects.get(id=sid) #试卷信息 paper=models.Paper.objects.filter(subject=subject1) # print('学号',sid,'考试科目',subject1) return render(request,'exam.html',{'student':student,'paper':paper,'subject':subject1}) exam模板如下：\n\u0026lt;!DOCTYPE HTML\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;meta http-equiv=\u0026quot;content-type\u0026quot; content=\u0026quot;text/html;charset=UTF-8\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot; /\u0026gt; \u0026lt;title\u0026gt;在线答题考试系统\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026quot;../static/bootstrap-4.3.1-dist/css/bootstrap.min.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;!-- 必须在引入bootstarp.js之前引入 --\u0026gt; \u0026lt;script src=\u0026quot;../static/jquery-3.3.1.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;../static/bootstrap-4.3.1-dist/js/bootstrap.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;../static/js/jquery-1.11.3.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;../static/js/jquery.countdown.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!--时间js--\u0026gt; \u0026lt;link href=\u0026quot;../static/css/main.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/css\u0026quot; /\u0026gt; \u0026lt;link href=\u0026quot;../static/css/test.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot; type=\u0026quot;text/css\u0026quot; /\u0026gt; \u0026lt;style\u0026gt; .hasBeenAnswer { background: #5d9cec; color:#fff; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;nav class=\u0026quot;navbar navbar-expand-sm bg-light navbar-light \u0026quot;\u0026gt; \u0026lt;ul class=\u0026quot;navbar-nav\u0026quot;\u0026gt; \u0026lt;li class=\u0026quot;nav-item active\u0026quot;\u0026gt; \u0026lt;a class=\u0026quot;nav-link\u0026quot;\u0026gt;\u0026lt;h3\u0026gt;在线考试系统\u0026lt;/h3\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;nav-item active\u0026quot;\u0026gt; \u0026lt;a class=\u0026quot;nav-link\u0026quot;\u0026gt;\u0026lt;h3\u0026gt;当前科目:{{ subject }}\u0026lt;/h3\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li style=\u0026quot;position: fixed;right: 70px; font-size: 30px;color: #9fcdff\u0026quot;\u0026gt;{{ student.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;div class=\u0026quot;main\u0026quot;\u0026gt; \u0026lt;!--nr start--\u0026gt; \u0026lt;div class=\u0026quot;test_main\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;nr_left\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;test\u0026quot;\u0026gt; \u0026lt;form action=\u0026quot;/calGrade/\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;sid\u0026quot; value=\u0026quot;{{ student.id }}\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;subject\u0026quot; value=\u0026quot;{{ subject }}\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;test_title\u0026quot;\u0026gt; \u0026lt;p class=\u0026quot;test_time\u0026quot;\u0026gt; \u0026lt;i class=\u0026quot;icon iconfont\u0026quot;\u0026gt;\u0026amp;#xe6fb;\u0026lt;/i\u0026gt;\u0026lt;b class=\u0026quot;alt-1\u0026quot;\u0026gt;01:40\u0026lt;/b\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;font\u0026gt;\u0026lt;input type=\u0026quot;submit\u0026quot; name=\u0026quot;tijiao\u0026quot; value=\u0026quot;交卷\u0026quot;\u0026gt;\u0026lt;/font\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;test_content\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;test_content_title\u0026quot;\u0026gt; \u0026lt;h2\u0026gt;单选题\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt; \u0026lt;span\u0026gt;共\u0026lt;/span\u0026gt;\u0026lt;i class=\u0026quot;content_lit\u0026quot;\u0026gt;10\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;题，\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;合计\u0026lt;/span\u0026gt;\u0026lt;i class=\u0026quot;content_fs\u0026quot;\u0026gt;10\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;分\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;test_content_nr\u0026quot;\u0026gt; \u0026lt;ul\u0026gt; {% for paper1 in paper %} {% for test in paper1.pid.all %} \u0026lt;li id=\u0026quot;{{ forloop.counter }}\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;test_content_nr_tt\u0026quot;\u0026gt; \u0026lt;i\u0026gt;{{ forloop.counter}}\u0026lt;/i\u0026gt;\u0026lt;span\u0026gt;({{ test.score }}分)\u0026lt;/span\u0026gt; \u0026lt;font\u0026gt;{{ test.title }}\u0026lt;/font\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;test_content_nr_main\u0026quot;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li class=\u0026quot;option\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; class=\u0026quot;radioOrCheck\u0026quot; name=\u0026quot;{{ test.id }}\u0026quot; value=\u0026quot;A\u0026quot;/\u0026gt; \u0026lt;label\u0026gt;A. \u0026lt;p class=\u0026quot;ue\u0026quot; style=\u0026quot;display: inline;\u0026quot;\u0026gt;{{ test.optionA }}\u0026lt;/p\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;option\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; class=\u0026quot;radioOrCheck\u0026quot; name=\u0026quot;{{ test.id }}\u0026quot; value=\u0026quot;B\u0026quot;/\u0026gt; \u0026lt;label\u0026gt; B.\u0026lt;p class=\u0026quot;ue\u0026quot; style=\u0026quot;display: inline;\u0026quot;\u0026gt;{{ test.optionB }}\u0026lt;/p\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;option\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; class=\u0026quot;radioOrCheck\u0026quot; name=\u0026quot;{{ test.id }}\u0026quot; value=\u0026quot;C\u0026quot;/\u0026gt; \u0026lt;label\u0026gt; C.\u0026lt;p class=\u0026quot;ue\u0026quot; style=\u0026quot;display: inline;\u0026quot;\u0026gt;{{ test.optionC }}\u0026lt;/p\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026quot;option\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; class=\u0026quot;radioOrCheck\u0026quot; name=\u0026quot;{{ test.id }}\u0026quot; value=\u0026quot;D\u0026quot;/\u0026gt; \u0026lt;label\u0026gt; D.\u0026lt;p class=\u0026quot;ue\u0026quot; style=\u0026quot;display: inline;\u0026quot;\u0026gt;{{ test.optionD }}\u0026lt;/p\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; {% endfor %} {% endfor %} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--nr end--\u0026gt; \u0026lt;div class=\u0026quot;foot\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果是这样的： 自动阅卷就简单了：\n 学生提交自己的作答给服务器（同时发送自己的学号和考试科目） 服务器根据考试科目找到该试卷，并逐个比较学生作答和答案是否一致，若一致，则得到该题的分数，并累加学生成绩 将学生的学号、该科成绩、科目名称作为一条记录插入到grade表中，返回首页  这里有个细节，试卷中会有很多选择题，后台一次会接收到多个提交答案，我是这样处理的，让每个单选题（有4个选项，使用同一name）的name属性和该题在题库表中的id 保持一致，这样在获取到题号后可以得到该题的答案，以便判断是否作答正确，详见exam.html。\n计算成绩的calGrade()视图函数如下：\ndef calGrade(request): if request.method=='POST': # 得到学号和科目 sid=request.POST.get('sid') subject1 = request.POST.get('subject') # 重新生成Student实例，Paper实例，Grade实例，名字和index中for的一致，可重复渲染 student= models.Student.objects.get(id=sid) paper = models.Paper.objects.filter(major=student.major) grade = models.Grade.objects.filter(sid=student.id) # 计算该门考试的学生成绩 question= models.Paper.objects.filter(subject=subject1).values(\u0026quot;pid\u0026quot;).values('pid__id','pid__answer','pid__score') mygrade=0#初始化一个成绩为0 for p in question: qId=str(p['pid__id'])#int 转 string,通过pid找到题号 myans=request.POST.get(qId)#通过 qid 得到学生关于该题的作答 # print(myans) okans=p['pid__answer']#得到正确答案 # print(okans) if myans==okans:#判断学生作答与正确答案是否一致 mygrade+=p['pid__score']#若一致,得到该题的分数,累加mygrade变量 #向Grade表中插入数据 models.Grade.objects.create(sid_id=sid,subject=subject1,grade=mygrade) # print(mygrade) # 重新渲染index.html模板 return render(request,'index.html',{'student':student,'paper':paper,'grade':grade}) （9）使用百度e-charts可视化数据 教师查看学生成绩，可以统计各个分数段的人数 我的思路：\n 教师查看学生成绩，点击查看成绩按钮后，发送该科科目名称给后台 后台视图函数接收科目名，从grade表计算该科目各个分数段的人数，发送给前台模板渲染，并可视化  视图函数如下：\n#教师查看成绩 def showGrade(request): subject1=request.GET.get('subject') grade=models.Grade.objects.filter(subject=subject1) data1 = models.Grade.objects.filter(subject=subject1, grade__lt=60).count() data2 = models.Grade.objects.filter(subject=subject1, grade__gte=60, grade__lt=70).count() data3 = models.Grade.objects.filter(subject=subject1, grade__gte=70, grade__lt=80).count() data4 = models.Grade.objects.filter(subject=subject1, grade__gte=80, grade__lt=90).count() data5 = models.Grade.objects.filter(subject=subject1, grade__gte=90).count() data = {'data1': data1, 'data2': data2, 'data3': data3, 'data4': data4, 'data5': data5} return render(request,'showGrade.html',{'grade':grade,'data':data,'subject':subject1}) 5.总结 第一次写博客，感觉还不错，希望和各位小伙伴讨论。 源码已上传至gitHub,去下载。\n","permalink":"https://trumpzhang.github.io/blog/django/django%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%80%83%E8%AF%95%E7%B3%BB%E7%BB%9F/","tags":["Django","python"],"title":"Django框架实现在线考试系统"},{"categories":["CentOS"],"contents":"CentOS7安装Mysql数据库 1.安装前的准备工作 (1)关闭selinux\n两种方式（建议2） #(1)临时关闭，及时生效，重启失效 [root@localhost ~]# setenforce 0 #(2)永久关闭，重启生效，永不失效 [root@localhost ~]# vi /etc/selinux/config 将SELINUX=enforcing修改为SELINUX=disabled，然后重启生效 (2)关闭防火墙\n两种方式(建议2) #(1).临时关闭：即时生效，重启失效 #查看防火墙状态 [root@localhost ~]# systemctl status firewalld.service #关闭防火墙 [root@localhost ~]# stop firewalld.service #继续查看防火墙状态 [root@localhost ~]# systemctl status firewalld.service 查看防火墙状态，可以看到，disactive（dead）的字样，说明防火墙已经关闭 方法1一旦重启操作系统，防火墙就自动开启了，该怎么设置才能永久关闭防火墙\n#(2).永久关闭防火墙,重启生效，永不失效 [root@localhost ~]# systemctl disable firewalld.service [root@localhost ~]# shutdown -r now 2.安装Mysql数据库（以Mysql 5.6为例）\n#检查是否安装Mysql [root@localhost ~]# yum list installed | grep mysql #若已安装，卸载 [root@localhost ~]# yum -y remove xxx #下载mysql 5.6的yum源 [root@localhost ~]# wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpm [root@localhost ~]# rpm -ivh mysql-community-release-el6-5. noarch.rpm [root@localhost ~]# yum repolist all | grep mysql #yum安装mysql [root@localhost ~]# yum install mysql-community-server -y #启动mysql服务 [root@localhost ~]# service mysqld start #设置mysql服务开机自启 [root@localhost ~]# chkconfig mysqld on 3.Mysql配置\n（1）设置root密码（mysql 5.7之前默认密码为空）\n#给root用户设置密码为 123456 [root@localhost ~]# mysql -uroot -p mysql\u0026gt; use mysql; mysql\u0026gt; update user set Password=password(‘123456’) where User=’root’; #刷新生效，否则要重启mysql服务 mysql\u0026gt; flush privileges; （2）修改mysql默认编码\n#查看数据库编码 mysql\u0026gt;show variables like ‘character%’; #修改my.conf配置文件 [root@localhost ~]# vi /etc/my.cnf #加入以下内容 [client] default-character-set=utf8 [mysqld] character-set-server=utf8 #重启mysql服务 [root@localhost ~]# service mysqld restart （3）mysql开启远程连接\nmysql\u0026gt; GRANT ALL PRIVILEGES ON *.* TO ‘root’@’%’IDENTIFIED BY ‘123456’WITH GRANT OPTION; mysql\u0026gt;flush privileges; #查看是否授权成功 mysql\u0026gt; select host,user from user; 此时，用navicat等工具再次连接，发现依然连接不上，这是因为mysql服务端会对客户端进行DNS反向解析 解决方法如下：打开my.cnf文件，在[mysqld]后加 skip-name-resolve（即跳过DNS域名解析）\n[root@localhost ~]# vi /etc/my.cnf [mysqld] skip-name-resolve //保存后重启mysql服务 [root@localhost ~]# service mysqld restart 重新连接 ：）\n","permalink":"https://trumpzhang.github.io/blog/centos/centos7%E5%AE%89%E8%A3%85mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","tags":["CentOS","mysql"],"title":"CentOS7安装Mysql数据库"},{"categories":["SSM"],"contents":"@[TOC](三.SSM框架之Spring MVC)\n三.Spring MVC 1.Spring MVC介绍 SpringMVC是Spring框架中用于Web应用开发的一个模块，是Spring提供的一个基于MVC设计模式的优秀Web开发框架，它在本质上相当于servlet。在MVC设计模式中，Spring MVC作为控制器(Controller)来建立模型与视图的数据交互，是结构最清晰的MVC Model2实现，是一个典型的MVC框架。 在Spring MVC框架中，Controller替代Servlet来担负控制器的职责，Controller接受请求，调用相应的Model进行处理，处理器完成业务处理后返回处理结果。Controller调用相应的View并对结果进行视图渲染，最终传送响应消息到客户端。 Spring MVC采用松耦合可插拔的组件结构，具有高度可配置性，比其他MVC更具扩展性和灵活性。此外，Spring MVC的注解驱动和对REST风格的支持，是他最具特色的功能。\n2.搭建环境  Spring MVC的配置 创建Controller 创建View（使用JSP作为视图） 部署运行  （1）使用Maven（管理你的jar包） 有时你的项目中所添加的jar包太多，导致你在别的机器上部署时非常困难，你需要去下载各种jar包，版本号也可能忘掉，使用Maven就可以很好的解决这些问题。 Maven是一个项目管理和综合工具。Maven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。 在多个开发团队环境时，Maven可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。\n建立Maven项目，打开IDEA-\u0026gt;New Project-\u0026gt;Maven，勾选Create from archetype,选择maven-archetype-webapp 建立demo2项目 打开pom.xml文件，输入依赖的jar包名及其版本：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;demo2 Maven Webapp\u0026lt;/name\u0026gt; \u0026lt;!-- FIXME change it to the project's website --\u0026gt; \u0026lt;url\u0026gt;http://www.example.com\u0026lt;/url\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring.version\u0026gt;5.0.3.RELEASE\u0026lt;/spring.version\u0026gt; \u0026lt;mybatis.version\u0026gt;3.4.4\u0026lt;/mybatis.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- 单元测试 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 第一部分：Spring 配置--\u0026gt; \u0026lt;!-- Spring core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context-support\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring DAO --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-tx\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring mvc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 第二部分：Servlet web --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;taglibs\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;standard\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 第三部分：数据库和mybatis --\u0026gt; \u0026lt;!-- 数据库 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.38\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 数据库连接池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mchange\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MyBatis --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis-spring整合包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 第四部分：日志 --\u0026gt; \u0026lt;!-- 实现slf4j接口并整合 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;onlineShop\u0026lt;/finalName\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 之后在src下建立java文件夹（mark as Sources Root）,建立resources文件夹（mark as Resources Root），复制前边java文件夹和resources文件夹下的文件到新的项目中。\n（2）在web.xml中配置Servlet DispatcherServlet是整个Spring MVC框架的核心，它负责截获请求并将其分派给相应的处理器处理。配置Spring MVC，首先要配置DispatcherServlet，跟所有的Servlet一样，必须在web.xml中进行配置。如下：\n\u0026lt;!DOCTYPE web-app PUBLIC \u0026quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\u0026quot; \u0026quot;http://java.sun.com/dtd/web-app_2_3.dtd\u0026quot; \u0026gt; \u0026lt;web-app xmlns=\u0026quot;http://xmlns.jcp.org/xml/ns/javaee\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\u0026quot; version=\u0026quot;3.1\u0026quot; metadata-complete=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;display-name\u0026gt;Archetype Created Web Application\u0026lt;/display-name\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:spring/spring-*.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- 默认匹配所有的请求 --\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt; org.springframework.web.filter.CharacterEncodingFilter \u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;/web-app\u0026gt; （2）创建Spring MVC的配置文件（spring-mvc.xml） 在spring文件夹下建立spring-mvc.xml文件，内容如下：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xmlns:mvc=\u0026quot;http://www.springframework.org/schema/mvc\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd\u0026quot;\u0026gt; \u0026lt;!-- 配置SpringMVC --\u0026gt; \u0026lt;!-- 1.开启SpringMVC注解模式 --\u0026gt; \u0026lt;!-- 简化配置： (1)自动注册DefaultAnootationHandlerMapping,AnotationMethodHandlerAdapter (2)提供一些列：数据绑定，数字和日期的format @NumberFormat, @DateTimeFormat, xml,json默认读写支持 --\u0026gt; \u0026lt;mvc:annotation-driven /\u0026gt; \u0026lt;!-- 2.静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用\u0026quot;/\u0026quot;做整体映射 --\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;!-- 3.配置jsp 显示ViewResolver --\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;viewClass\u0026quot; value=\u0026quot;org.springframework.web.servlet.view.JstlView\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;prefix\u0026quot; value=\u0026quot;/WEB-INF/jsp/\u0026quot; /\u0026gt; \u0026lt;property name=\u0026quot;suffix\u0026quot; value=\u0026quot;.jsp\u0026quot; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 4.扫描web相关的bean --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;com.controller\u0026quot; /\u0026gt; \u0026lt;/beans\u0026gt; （3）创建Controller 右击com包-\u0026gt;New-\u0026gt;Package-\u0026gt;输入包名\u0026quot;controller\u0026rdquo; 在controller包下建立名为\u0026quot;UserController\u0026quot;的Java Class\npackage com.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class UserController { @RequestMapping(\u0026quot;/first\u0026quot;) public String login(){ return \u0026quot;first\u0026quot;; } } （4）创建View webapp下建立jsp文件夹，jsp下建立first.jsp文件\n \u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;first\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;欢迎访问first.jsp\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （5）部署运行 安装好Tomcat Add Configuration-\u0026gt;Templates-\u0026gt;Tomcat Server-\u0026gt;Local Configure-\u0026gt;选择Tomcat的安装目录，选择Deployment-\u0026gt;demo2 war exploded，点击Apply，点击OK\n步骤如下： 修改index.jsp的内容，向其中加入一个超链接 index.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;% String appPath=request.getContextPath(); %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;Hello World!\u0026lt;/h2\u0026gt; \u0026lt;a href=\u0026quot;\u0026lt;%=appPath%\u0026gt;/first\u0026quot;\u0026gt;跳转到first.jsp\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 点击绿色小按钮，启动TomCat服务器，等待浏览器自动打开： 点击链接： 3.向视图发送数据 在数据库test的user表中插入几条数据，下面演示如何将user中的数据打印在first.jsp上\n 在UserDao接口中写queryAllUser方法  package com.dao; import com.pojo.User; import java.util.List; public interface UserDao { List\u0026lt;User\u0026gt; queryAllUser(); } 在UserMapper.xml中实现queryAllUser方法  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;httpz://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;!--映射器--\u0026gt; \u0026lt;mapper namespace=\u0026quot;com.dao.UserDao\u0026quot;\u0026gt; \u0026lt;!--将数据库member表映射到memberResultMap中 类型为Member --\u0026gt; \u0026lt;resultMap id=\u0026quot;userResultMap\u0026quot; type=\u0026quot;User\u0026quot;\u0026gt; \u0026lt;result property=\u0026quot;name\u0026quot; column=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;password\u0026quot; column=\u0026quot;password\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--sql语句--\u0026gt; \u0026lt;!--实现memDao的增删改查抽象方法--\u0026gt; \u0026lt;select id=\u0026quot;queryAllUser\u0026quot; resultMap=\u0026quot;userResultMap\u0026quot;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 建立服务层（DAO层为服务层提供底层API）,在com包下建立service包，service包下建立impl包。建立spring-services.xml文件，如下：  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xmlns:tx=\u0026quot;http://www.springframework.org/schema/tx\u0026quot; xmlns:jdbc=\u0026quot;http://www.springframework.org/schema/jdbc\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd\u0026quot;\u0026gt; \u0026lt;!-- 扫描service包下所有使用注解的类型 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;com.service\u0026quot; /\u0026gt; \u0026lt;!-- 配置事务管理器 --\u0026gt; \u0026lt;bean id=\u0026quot;transactionManager\u0026quot; class=\u0026quot;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026quot;\u0026gt; \u0026lt;!-- 注入数据库连接池 --\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 配置基于注解的声明式事务 --\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026quot;transactionManager\u0026quot; /\u0026gt; \u0026lt;/beans\u0026gt; 整体目录如下： service包下建立“UserService”接口  package com.service; import com.pojo.User; import java.util.List; public interface UserService { List\u0026lt;User\u0026gt; queryAllUser(); } impl包下建立UserServicesImpl来实现UserService接口（注意添加注释@Service指出服务层，调用DAO层时需要使用AutoWired装配userDao）  package com.service.impl; import com.dao.UserDao; import com.pojo.User; import com.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; public List\u0026lt;User\u0026gt; queryAllUser() { return userDao.queryAllUser(); } } 在UserController启用自动装配，调用UserService的queryAllUser方法，将其添加到model中，将数据发送至first.jsp  package com.controller; import com.pojo.User; import com.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import java.util.List; @Controller public class UserController { @Autowired private UserService userService; // url请求 @RequestMapping(\u0026quot;/first\u0026quot;) public String login(Model model){ // 调用服务层实现查询所有信息的功能 List\u0026lt;User\u0026gt; allUser=userService.queryAllUser(); // 将结构保存至model中 model.addAttribute(\u0026quot;allUser\u0026quot;,allUser); // 转到first.jsp，同时发送model的所有数据 return \u0026quot;first\u0026quot;; } } first.jsp接受数据并进行渲染，使用BootStrap的表格显示model的数据，（此处需要用到JSTL）,我们修改first.jsp为：  \u0026lt;%@ taglib prefix=\u0026quot;c\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; %\u0026gt; \u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;% String appPath = request.getContextPath(); %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;first\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt; \u0026lt;!-- 引入 Bootstrap --\u0026gt; \u0026lt;link href=\u0026quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;row clearfix\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-md-12 column\u0026quot;\u0026gt; \u0026lt;table class=\u0026quot;table table-hover table-striped\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;password\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;c:forEach var=\u0026quot;member1\u0026quot; items=\u0026quot;${requestScope.get('allUser')}\u0026quot; varStatus=\u0026quot;status\u0026quot;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${member1.name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${member1.password}\u0026lt;/td\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/c:forEach\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 我们部署项目，查看是否成功执行 4.View向Controller传参 假设现在要实现一个删除功能，即能根据name属性删除该记录，向first.jsp中加入一行代码：\n\u0026lt;%@ taglib prefix=\u0026quot;c\u0026quot; uri=\u0026quot;http://java.sun.com/jsp/jstl/core\u0026quot; %\u0026gt; \u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;% String appPath = request.getContextPath(); %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;后台\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt; \u0026lt;!-- 引入 Bootstrap --\u0026gt; \u0026lt;link href=\u0026quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;row clearfix\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-md-12 column\u0026quot;\u0026gt; \u0026lt;table class=\u0026quot;table table-hover table-striped\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;password\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;c:forEach var=\u0026quot;member1\u0026quot; items=\u0026quot;${requestScope.get('allUser')}\u0026quot; varStatus=\u0026quot;status\u0026quot;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${member1.name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${member1.password}\u0026lt;/td\u0026gt; \u0026lt;%--加入删除，${member1.name}为向controller传递的参数--%\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026quot;\u0026lt;%=appPath%\u0026gt;/delByName/${member1.name}\u0026quot;\u0026gt;删除\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/c:forEach\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; first.jsp变为这样：  在DAO中添加delByName方法  package com.dao; import com.pojo.User; import java.util.List; public interface UserDao { List\u0026lt;User\u0026gt; queryAllUser(); int delByName(String name); } 在UserMapper.xml实现delByName  \u0026lt;delete id=\u0026quot;delByName\u0026quot; parameterType=\u0026quot;String\u0026quot;\u0026gt; delete from user where name=#{name} \u0026lt;/delete\u0026gt; 在服务层UserService接口中写一个DelByName方法，并在UserServiceImpl中实现该接口的方法 UserService:  package com.service; import com.pojo.User; import java.util.List; public interface UserService { List\u0026lt;User\u0026gt; queryAllUser(); int delByName(String name); } UserServiceImpl:\npackage com.service.impl; import com.dao.UserDao; import com.pojo.User; import com.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; public List\u0026lt;User\u0026gt; queryAllUser() { return userDao.queryAllUser(); } public int delByName(String name){ return userDao.delByName(name); } } 在UserController中实现delByName请求：  package com.controller; import com.pojo.User; import com.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import java.util.List; @Controller public class UserController { @Autowired private UserService userService; // url请求 @RequestMapping(\u0026quot;/first\u0026quot;) public String login(Model model){ // 调用服务层实现查询所有信息的功能 List\u0026lt;User\u0026gt; allUser=userService.queryAllUser(); // 将结构保存至model中 model.addAttribute(\u0026quot;allUser\u0026quot;,allUser); // 转到first.jsp，同时发送model的所有数据 return \u0026quot;first\u0026quot;; } @RequestMapping(\u0026quot;/delByName/{name}\u0026quot;) public String del(@PathVariable(\u0026quot;name\u0026quot;)String name1){//接受到name userService.delByName(name1);//调用delByName方法 return \u0026quot;redirect:/first\u0026quot;;//重定向到first } } 实现效果： View可一次传送多个参数给Controller。\n","permalink":"https://trumpzhang.github.io/blog/ssm/springmvc/","tags":["SSM","Spring MVC"],"title":"SpringMvc"},{"categories":["SSM"],"contents":"@TOC\n二.MyBatis框架 1.MyBatis及ORM简介  MyBatis是一个优秀的数据持久层框架，在实体类和SQL语句之间建立映射关系，是一种半自动化的ORM实现。其封装性要低于Hibernate，性能优越，并且小巧、简单易学，应用也越来越广泛。 它内部封装了通过JDBC访问数据库的操作，支持普通的SQL查询、存储过程和高级映射，几乎消除了所有的JDBC代码和参数的手工设置以及结果集的检索 关于ORM(Object Relational Mapping )，你应该知道的: （1）对象/关系映射是一种数据持久化技术。它在对象模型和关系型数据库之间建立起对应关系，并且提供了一种机制，通过JavaBean对象去操作数据库表中的数据。 （2）在开发中，程序员使用面向对象的技术操作数据，而当存储数据时，使用的却是关系数据库，这样造成了很多不便。ORM在对象模型和关系数据库的表之间建立了一座桥梁，有了它，程序员就不需要再使用SQL语句操作数据库中的表，使用API直接操作JavaBean对象就可以实现数据的查询、存储、更改、删除等操作。 （3）MyBatis通过简单的XML或者注解进行配置和原始映射，在实体类和SQL语句之间建立映射关系，是一种半自动化的ORM实现。 MyBatis是ORM的解决方案，下面通过简单的实例体验MyBatis  2.搭建MyBatis环境  在项目中配置jdbc驱动包 点击Project Structure按钮，选择左侧modules,选择Dependencies选项卡，点击“+”，选择“Jars or directories”，找到驱动jar包，Apply之后点击Ok  使用navicat建立两张表user(name,password)和book(id,name)，并插入几条记录作为测试   user表  book表   建立和表对应的pojo类 建立pojo（plain old java object）包，右击com包 -\u0026gt;new -\u0026gt;Package-\u0026gt;pojo 在pojo下建立两个Java类,即User类、Book类   User类  package com.pojo; public class User { // 类型和数据库保持一致，varchar对应String private String name; private String password; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } }  Book类  package com.pojo; public class Book { // 类型和数据库保持一致，varchar对应String private int id; private String name; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 建立dao层（data access object）,数据访问层，用来访问数据库 右击 com包 -\u0026gt; New -\u0026gt; Package-\u0026gt;输入 dao 在dao包中建立两个类的接口，UserDao、BookDao: 右击dao-\u0026gt; New -\u0026gt; Java Class-\u0026gt;输入\u0026quot;UserDao\u0026rdquo;，kind选择\u0026quot;interface\u0026rdquo;   UserDao  package com.dao; import com.pojo.User; import java.util.List; public interface UserDao { List\u0026lt;User\u0026gt; queryAllUser();//查询所有user int addUser(User user);//添加user }  BookDao  package com.dao; import com.pojo.Book; import java.util.List; public interface BookDao { List\u0026lt;Book\u0026gt; queryAllBook();//查询所有书籍 int addBook(Book book);//添加书籍 } 建立jdbc.properties文件，典型的Java属性配置文件 右击resources文件夹-\u0026gt;new -\u0026gt;File-\u0026gt;jdbc.properties(带后缀) 配置mysql数据库，使用test库  jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8 jdbc.username=root jdbc.password=123456 建立类的映射文件夹（mapper） 右击 resources -\u0026gt;New -\u0026gt; Directory -\u0026gt; mapper 在mapper文件夹下建立UserMapper.xml和BookMapper.xml映射文件   UserMapper.xml内容如下，BookMapper同UserMapper.xml  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;httpz://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt; \u0026lt;!--映射器--\u0026gt; \u0026lt;mapper namespace=\u0026quot;com.dao.UserDao\u0026quot;\u0026gt; \u0026lt;!--将数据库user表映射到userResultMap中 类型为User --\u0026gt; \u0026lt;resultMap id=\u0026quot;userResultMap\u0026quot; type=\u0026quot;User\u0026quot;\u0026gt; \u0026lt;result property=\u0026quot;name\u0026quot; column=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;result property=\u0026quot;password\u0026quot; column=\u0026quot;password\u0026quot;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--sql语句--\u0026gt; \u0026lt;!--实现userDao中定义的 queryAllUser 方法--\u0026gt; \u0026lt;select id=\u0026quot;queryAllUser\u0026quot; resultMap=\u0026quot;userResultMap\u0026quot;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;!--实现userDao中定义的 addUser 方法--\u0026gt; \u0026lt;insert id=\u0026quot;addUser\u0026quot; parameterType=\u0026quot;User\u0026quot;\u0026gt; insert into user(name,password) value (#{name},#{password}) \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt; 核心配置文件configuration.xml 右击resources -\u0026gt;File -\u0026gt; mybatis-config.xml  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 引入外部资源文件 --\u0026gt; \u0026lt;properties resource=\u0026quot;jdbc.properties\u0026quot;\u0026gt;\u0026lt;/properties\u0026gt; \u0026lt;!-- 设置驼峰匹配 --\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026quot;mapUnderscoreToCamelCase\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;!-- 设置包扫描(别名) --\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026quot;com.pojo\u0026quot;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;!-- 配置环境：可以配置多个环境，default：配置某一个环境的唯一标识，表示默认使用哪个环境 --\u0026gt; \u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt; \u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt; \u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt; \u0026lt;!-- 配置连接信息 --\u0026gt; \u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;${jdbc.driverClass}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${jdbc.url}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${jdbc.username}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${jdbc.password}\u0026quot;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!-- 配置映射文件：用来配置sql语句和结果集类型等 --\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026quot;classpath:mapper/*.xml\u0026quot;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 目录结构如下： 3.MyBatis语法 MyBatis的真正强大之处在于SQL映射语句，也是它的魅力所在，使用SQL映射文件配置可减少50%以上的代码量，MyBatis专注于SQL。关于SQL映射文件的几个元素配置：\n  mapper:映射元素的根元素节点，只有一个namespace（命名空间），其主要作用在于：\n 区分不同的mapper，全局唯一 绑定DAO接口，即面向接口编程    ResultMap:用来描述数据库结果集和对象的对应关系\n  sql:可以重用的SQL块\n  insert:映射插入语句\n dao中 int addMember(Member member);， mapper中这样写（id和方法名一致）： \u0026lt;insert id=\u0026quot;addMember\u0026quot; parameterType=\u0026quot;Member\u0026quot;\u0026gt; insert into member(memName,password) value (#{memName},#{password}) \u0026lt;/insert\u0026gt;    delete:映射删除语句\n dao 中int deleteMemberById(int memId); mapper中这样写 \u0026lt;delete id=\u0026quot;deleteMemberById\u0026quot; parameterType=\u0026quot;int\u0026quot;\u0026gt; delete from member where memId=#{memId} \u0026lt;/delete\u0026gt;    select:映射查询语句\n dao 中Member queryById(int memId); mapper中这样写 \u0026lt;select id=\u0026quot;queryById\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;Member\u0026quot;\u0026gt; select * from member where memId=#{memId} \u0026lt;/select\u0026gt;    update:映射更新语句\n dao中 int updateMember(Member member); mapper可以这样写 \u0026lt;update id=\u0026quot;updateMember\u0026quot; parameterType=\u0026quot;Member\u0026quot;\u0026gt; update member set memName=#{memName},sex=#{sex},password=#{password} \u0026lt;/update\u0026gt;    parameterType:参数类型（int、String、某个pojo）\n  resultType:返回查询的类型，像这样的sql语句：select * from user where id=1 ，只返回1个对象,可为它指定ResultType为User。insert、update、delete元素中均无resultType属性，只有查询操作需要对返回结果指定\n  ResultMap：是对外部resultMap定义的引用，对应外部resultMap的id,像这样的一条sql语句select * from student where age\u0026gt;20会返回多个student对象，可为它指定resultMap为studentResultMap，即ResultMap常用于会返回多条记录是使用。\n  4.实现Spring对MyBatis的整合 1. 配置DataSource 我们将MyBatis配置文件中有关数据源的配置转移到Spring配置文件中单独进行维护。 在Spring中配置数据源，首先要选择一种具体的数据源实现技术，有dbcp、c3p0、Proxool等，以配置c3p0为例： 建立Spring的配置文件，右击resources -\u0026gt;New-\u0026gt;Directory-\u0026gt;\u0026quot;Spring\u0026rdquo; 右击Spring文件夹-\u0026gt;new-\u0026gt;File-\u0026gt;\u0026quot;spring-dao.xml\u0026rdquo;，输入以下代码：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xmlns:context=\u0026quot;http://www.springframework.org/schema/context\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026quot;\u0026gt; \u0026lt;!-- 配置整合mybatis过程 --\u0026gt; \u0026lt;!-- 1.配置数据库相关参数properties的属性：${url} --\u0026gt; \u0026lt;context:property-placeholder location=\u0026quot;classpath:jdbc.properties\u0026quot;/\u0026gt; \u0026lt;!-- 2.数据库连接池 --\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;com.mchange.v2.c3p0.ComboPooledDataSource\u0026quot;\u0026gt; \u0026lt;!-- 配置连接池属性 --\u0026gt; \u0026lt;property name=\u0026quot;driverClass\u0026quot; value=\u0026quot;${jdbc.driver}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;jdbcUrl\u0026quot; value=\u0026quot;${jdbc.url}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;user\u0026quot; value=\u0026quot;${jdbc.username}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${jdbc.password}\u0026quot;/\u0026gt; \u0026lt;!-- c3p0连接池的私有属性 --\u0026gt; \u0026lt;property name=\u0026quot;maxPoolSize\u0026quot; value=\u0026quot;30\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;minPoolSize\u0026quot; value=\u0026quot;10\u0026quot;/\u0026gt; \u0026lt;!-- 关闭连接后不自动commit --\u0026gt; \u0026lt;property name=\u0026quot;autoCommitOnClose\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;!-- 获取连接超时时间 --\u0026gt; \u0026lt;property name=\u0026quot;checkoutTimeout\u0026quot; value=\u0026quot;10000\u0026quot;/\u0026gt; \u0026lt;!-- 当获取连接失败重试次数 --\u0026gt; \u0026lt;property name=\u0026quot;acquireRetryAttempts\u0026quot; value=\u0026quot;2\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 3.配置SqlSessionFactory对象 --\u0026gt; \u0026lt;bean id=\u0026quot;sqlSessionFactory\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionFactoryBean\u0026quot;\u0026gt; \u0026lt;!-- 注入数据库连接池 --\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;/\u0026gt; \u0026lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --\u0026gt; \u0026lt;property name=\u0026quot;configLocation\u0026quot; value=\u0026quot;classpath:mybatis-config.xml\u0026quot;/\u0026gt; \u0026lt;!-- 扫描pojo包 使用别名 --\u0026gt; \u0026lt;property name=\u0026quot;typeAliasesPackage\u0026quot; value=\u0026quot;com.pojo\u0026quot;/\u0026gt; \u0026lt;!-- 扫描sql配置文件:mapper需要的xml文件 --\u0026gt; \u0026lt;property name=\u0026quot;mapperLocations\u0026quot; value=\u0026quot;classpath:mapper/*.xml\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --\u0026gt; \u0026lt;bean class=\u0026quot;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026quot;\u0026gt; \u0026lt;!-- 注入sqlSessionFactory --\u0026gt; \u0026lt;property name=\u0026quot;sqlSessionFactoryBeanName\u0026quot; value=\u0026quot;sqlSessionFactory\u0026quot;/\u0026gt; \u0026lt;!-- 给出需要扫描Dao接口包 --\u0026gt; \u0026lt;property name=\u0026quot;basePackage\u0026quot; value=\u0026quot;com.dao\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 将mybatis-config.xml中内容修改为：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 配置全局属性 --\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --\u0026gt; \u0026lt;setting name=\u0026quot;useGeneratedKeys\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;!-- 使用列别名替换列名 默认:true --\u0026gt; \u0026lt;setting name=\u0026quot;useColumnLabel\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;!-- 开启驼峰命名转换:Table{create_time} -\u0026gt; Entity{createTime} --\u0026gt; \u0026lt;setting name=\u0026quot;mapUnderscoreToCamelCase\u0026quot; value=\u0026quot;true\u0026quot; /\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;/configuration\u0026gt; 整合完成\n","permalink":"https://trumpzhang.github.io/blog/ssm/mybatis/","tags":["SSM","mybatis"],"title":"Mybatis"},{"categories":["SSM"],"contents":"@TOC\n前言 SSM（Spring+SpringMVC+MyBatis）框架集由Spring、MyBatis两个开源框架整合而成（SpringMVC是Spring中的部分内容）。常作为数据源较简单的web项目的框架。 本博客可作为SSM的入门教程，我分为了三个部分，即Spring、Spring MVC、MyBatis，每个部分包含简单的应用实例。 最后完成一个简单的在线商城\n一.Spring框架 1.认识Spring 1.1传统JavaEE开发 传统JavaEE项目在解决企业级应用问题时的“重量级”架构体系，使它的开发效率、开发难度和实际性能都令人失望。Spring以一个“救世主”形象出现在广大Java程序员面前。2002年，Rod Johnson在他的《Expert One-on-One Java EE Design and Development》一书中提出了Interface 21，也就是Spring框架的雏形。他提出技术应该以应用为主的主张，引发了人们对“正统”JavaEE的反思。2003年2月，Spring框架正式成为一个开源项目，并发布于SourceForge中。 Spring致力于JavaEE应用的各种解决方案，而不仅仅专注于某一层的方案，贯穿表现层、业务层和持久层。\n1.2 Spring整体架构 以下图片摘自百度搜索引擎 作为一个全面的解决方案，Spring坚持一个原则：不重新发明轮子，例如，对象持久化和ORM,Spring只是对现有的JDBC、Mybatis、Hibernate等技术提供支持，使之更易用。而不是重复实现。\n Spring Core是框架的基础部分，提供了IoC特性 Spring Context为企业级开发提供了便利的集成工具 Spring JDBC提供了JDBC的抽象层，简化了JDBC编码，同时使代码更健壮。 Spring ORM对市面上流行的ORM框架提供了支持 Spring Web为Spring在Web应用程序中的使用提供了支持  1.2.1 IoC/DI 控制反转（Inversion of Control,IoC）也称为依赖注入（Dependency Injection,DI）,用来降低程序代码之间的耦合度。 例如，在A类的方法中实例化了B类的对象，并调用其方法实现某种功能，则称A类依赖于B类。常见的业务层调用数据访问层以实现持久化操作\n//用户DAO接口，定义了所需的持久化方法DAO(Data Access Object) public interface UserDao { //保存信息方法 public void save(User user); } //用户DAO实现类，实现对User类的持久化操作 public class UserDaoImpl implements UserDao{ public void save(User user){ System.out.println(\u0026quot;已保存\u0026quot;); } } //用户业务类，实现对User功能的业务管理 public class UserServiceImpl implements UserService{ private UserDao dao=new UserDaoImpl(); public void addNewUser(User user){ dao.save(user); } } 上面代码，UserServiceImpl对UserDaoImpl存在依赖关系，这样的代码存在严重的问题，即UserServiceImpl和UserDaoImpl高度耦合，如果因为需求变化需要替换UserDao的实现类，将导致UserServiceImpl中的代码随之发生修改。 而Spring能够分担这些额外的工作，并提供了完整的IoC实现，让我们得以专注于业务类和DAO类的设计与实现。 使用Spring 实现输出\n 开发环境的搭建，使用地表最强IDE—— JetBrains的IntelliJ IDEA  create New project-\u0026gt;选择Spring-\u0026gt;输入项目名（idea会自动下载Spring所需jar包，若下载不成功，请翻墙）\n右击-\u0026gt;src-\u0026gt;new-\u0026gt;package-\u0026gt;输入包名(我使用com)-\u0026gt;右击包-\u0026gt;new-\u0026gt;Java Class-\u0026gt;建立“HelloSpring”Java类\npackage com; public class HelloSpring { private String str=null; public void print(){ System.out.println(\u0026quot;hello,\u0026quot;+this.getStr()); } public String getStr() { return str; } public void setStr(String str) { this.str = str; } } 继续建立Spring的配置文件： 右击项目名-\u0026gt;new-\u0026gt;Directory-\u0026gt;输入“resources”-\u0026gt;右击“resources”-\u0026gt;Mark Directory As-\u0026gt;Resources Root，右击Resources文件夹，选择new-\u0026gt;File-\u0026gt;创建 applicationContext.xml \u0026ldquo;applicationContext.xml\u0026quot;文件内容如下，配置Spring\n\u0026lt;beans xmlns=\u0026quot;http://www.springframework.org/schema/beans\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026quot;\u0026gt; \u0026lt;!--通过bean元素声明需要Spring创建的实例。该实例的类型通过class属性指定， 并通过id属性为该实例指定一个名称，便于访问--\u0026gt; \u0026lt;bean id=\u0026quot;HelloSpring\u0026quot; class=\u0026quot;com.HelloSpring\u0026quot;\u0026gt; \u0026lt;!--pro[erty元素用来为实例的属性赋值--\u0026gt; \u0026lt;property name=\u0026quot;str\u0026quot;\u0026gt; \u0026lt;value\u0026gt;Spring\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 在com包下建立Test 主类来测试：\npackage com; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Test { public static void main(String[]args){ String config=\u0026quot;applicationContext.xml\u0026quot;; ApplicationContext ac=new ClassPathXmlApplicationContext(config); HelloSpring helloSpring=(HelloSpring)ac.getBean(\u0026quot;HelloSpring\u0026quot;); //运行print方法 helloSpring.print(); } } 运行Test类主方法，查看控制台，看到成功输出了信息： 这种做法解释了spring的“注入”，应用程序通过BeanFactory接口与Spring IoC容器交互， ApplicationContext是BeanFactory的子接口，负责读取Spring配置文件，管理对象的加载、 生成，维护Bean对象之间的依赖关系，负责Bean的生命周期等。\n1.2.2 AOP 现实中有一些内容并不是面向对象（OOP）可以解决的，比如数据库事务，它对于企业级的Java EE应用而言是十分重要的。\n面向切面编程 (Aspect Oriented Programming),时软件编程思想发展到一定阶段的产物，是对面向对象编程（Object Oriented Programming,OOP）的有益补充。AOP一般适用于具有横切逻辑的场合，如访问控制、事务管理、性能检测等。\n面向切面编程，简单的说就是在不改变原有程序的基础上为代码段增加新的功能，对其进行增强处理。它的设计思想来源于代理设计模式。 面向切面的一些基本概念：\n 切面（Aspect）:一个模块化的横切逻辑（或称横切关注点），可能会横切多个对象 连接点（Join Point）：程序执行中的某个具体的执行点 增强处理（Advice）：切面在某个特定连接点上执行的代码逻辑 切入点（PointCut）：对连接点的特征进行描述 目标对象（Target Object）:被一个或多喝切面增强的对象 AOP代理（AOP proxy）：由AOP框架所创建的对象，实现执行增强处理方法等功能 织入（weaving）：将增强处理连接到应用程序中的类型或对象上的过程  在线商城的源码已上传至github 去下载https://github.com/HelloZzy23/onlineShop\n","permalink":"https://trumpzhang.github.io/blog/ssm/spring/","tags":["SSM","Spring"],"title":"Spring"},{"categories":["Scala"],"contents":"1.安装Scala并配置环境变量（一般在安装时就配好了）\n2.检查idea版本（插件必须与idea版本兼容）Help-\u0026gt;About，可以看到为2018.3.2\n3.下载idea的开发插件（.zip文件）下载2018.3.X的插件即可\nhttps://plugins.jetbrains.com/plugin/1347-scala\n无需解压，将此文件拷贝至idea安装目录/Plugins下\n4.打开idea-\u0026gt;File-\u0026gt;setting-\u0026gt;plugins-\u0026gt;install plugin from disk，重启idea\n5.创建第一个Scala示例\nFile-\u0026gt;New -\u0026gt;Project-\u0026gt;Scala-\u0026gt;IDEA\ncom包-\u0026gt;new-\u0026gt;Scala class-\u0026gt;输入HelloWorld，Kind选择Object，运行即可\npackage com object HelloWorldScala { def main(args: Array[String]): Unit = { println(\u0026#34;hello world\u0026#34;); } } ","permalink":"https://trumpzhang.github.io/blog/scala/1.scala%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","tags":["Scala"],"title":"scala开发环境配置"},{"categories":["Hadoop"],"contents":"Hadoop3.2.1 分布式集群安装 1.准备环境： 3 台 linux 虚拟机(CentOs7.x 64 位)\n ip 为： 192.168.2.100 192.168.2.101 192.168.2.102 对应的 hostname 为： hadoop100 hadoop101 hadoop102  2.虚拟机基本环境配置： 这三台机器的基本配置参考 Hadoop 单机伪分布安装章节中的虚拟机基本环境配置部分。 注意：除了基本配置之外还需要实现主节点能够免密码登陆到所有从节点，因为从节点上面的进程是由主节点通过 ssh 远程启动的。 在 hadoop100 这台机器上执行下面命令，可以实现主节点免密码登陆到所有从节点。\n[root@hadoop100 ~]# ssh-copy-id -i hadoop101 [root@hadoop100 ~]# ssh-copy-id -i hadoop102 在 hadoop100 机器上使用 ssh 命令确认集群免密码登陆是否设置成功，如果可以免密码登陆进去就说明是没有问题的。\n[root@hadoop100 ~]# ssh hadoop101 [root@hadoop100 ~]# ssh hadoop101 3.Hadoop 分布式集群安装： 注意：在这里我们用到了前面安装伪分布集群的机器 hadoop100，所以需要先把之前的伪分布集群停掉，然后删除/data 目录下的 hadoop_repo和/data/soft 目录下的 hadoop-3.2.1目录，恢复此机器的环境。 下面开始安装 hadoop 分布式集群。 首先在 hadoop100 节点上安装。\n 把 hadoop-3.2.1.tar.gz 安装包上传到 linux 机器的/data/soft 目录下 解压 hadoop 安装包 [root@hadoop100 ~]# cd /data/soft [root@hadoop100 soft]# tar -zxvf hadoop-3.2.1.tar.gz 修改 hadoop 相关配置文件 #进入配置文件所在目录  [root@hadoop100 soft]# cd hadoop-3.2.1/etc/hadoop/  #首先修改 hadoop-env.sh 文件，增加环境变量信息  [root@hadoop100 hadoop]# vi hadoop-env.sh export JAVA_HOME=/data/soft/jdk1.8 export HADOOP_LOG_DIR=/data/hadoop_repo/logs/hadoop  修改 core-site.xml 文件，注意 fs.defaultFS 属性中的主机名需要和你配置的主机名保持一致  [root@hadoop100 hadoop]# vi core-site.xml \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hdfs://hadoop100:9000\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.tmp.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/data/hadoop_repo\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt;  修改 hdfs-site.xml 文件，把 hdfs 中文件副本的数量设置为2，因为现在分布集群有2个节点  [root@hadoop100 hadoop]# vi hdfs-site.xml \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.replication\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;2\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.namenode.secondary.http-address\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hadoop100:50090\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt;  修改 mapred-site.xml，设置 mapreduce 使用的资源调度框架  [root@hadoop100 hadoop]# vi mapred-site.xml \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.framework.name\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;yarn\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.app.mapreduce.am.env\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;HADOOP_MAPRED_HOME=/data/soft/hadoop-3.2.1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.map.env\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;HADOOP_MAPRED_HOME=/data/soft/hadoop-3.2.1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.reduce.env\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;HADOOP_MAPRED_HOME=/data/soft/hadoop-3.2.1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt;  修改 yarn-site.xml，设置 yarn 上支持运行的服务和环境变量白名单  [root@hadoop100 hadoop]# vi yarn-site.xml \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.aux-services\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;mapreduce_shuffle\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.env-whitelist\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CL ASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.resourcemanager.hostname\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hadoop100\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt;  修改 workers 文件，增加所有从节点的主机名，一个一行  [root@hadoop100 hadoop]# vi workers hadoop101 hadoop102 #修改启动脚本 #修改 start-dfs.sh，stop-dfs.sh 这两个脚本文件，在文件前面增加如下内容 [root@hadoop100 hadoop]# cd /data/soft/hadoop-3.2.1/sbin [root@hadoop100 sbin]# vi start-dfs.sh HDFS_DATANODE_USER=root HDFS_DATANODE_SECURE_USER=hdfs HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root [root@hadoop100 sbin]# vi stop-dfs.sh HDFS_DATANODE_USER=root HDFS_DATANODE_SECURE_USER=hdfs HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root  修改 start-yarn.sh，stop-yarn.sh 这两个脚本文件，在文件前面增加如下内容  [root@hadoop100 sbin]# vi start-yarn.sh YARN_RESOURCEMANAGER_USER=root HADOOP_SECURE_DN_USER=yarn YARN_NODEMANAGER_USER=root [root@hadoop100 sbin]# vi stop-yarn.sh YARN_RESOURCEMANAGER_USER=root HADOOP_SECURE_DN_USER=yarn YARN_NODEMANAGER_USER=root 4.把 hadoop100 节点上修改好配置的安装包拷贝到其他两个从节点 [root@hadoop100 hadoop]# cd /data/soft/ [root@hadoop100 soft]# scp -rq hadoop-3.2.1.tar.gz hadoop101:/data/soft/ [root@hadoop100 soft]# scp -rq hadoop-3.2.1.tar.gz hadoop102:/data/soft/ 5.格式化 namenode [root@hadoop100 hadoop]# cd /data/soft/hadoop-3.2.1 [root@hadoop100 hadoop-3.2.1]# bin/hdfs namenode -format 如果在后面的日志信息中能看到这一行，则说明 namenode 格式化成功。 common.Storage: Storage directory /data/hadoop_repo/dfs/name has been successfully formatted.\n6.启动集群，在 hadoop100 节点上执行下面命令 [root@hadoop100 hadoop-3.2.1]# sbin/start-all.sh Starting namenodes on [hadoop100] Starting datanodes Starting secondary namenodes [hadoop100] Starting resourcemanager Starting nodemanagers 7.验证集群 分别在 3 台机器上执行 jps 命令，进程信息如下所示：\n 在 hadoop100 节点执行 [root@hadoop100 hadoop-3.2.1]# jps 8802 ResourceManager 8572 SecondaryNameNode 8334 NameNode 在 hadoop101 节点执行 [root@hadoop101 hadoop-3.2.1]# jps 2229 NodeManager 2124 DataNode 在 hadoop102 节点执行 [root@hadoop102 hadoop-3.2.1]# jps 1857 DataNode 1963 NodeManager  至此，hadoop 分布式集群安装成功！\n","permalink":"https://trumpzhang.github.io/blog/hadoop/2.hadoop3.2.1%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/","tags":["Hadoop"],"title":"2.Hadoop3.2"},{"categories":["Hadoop"],"contents":"Hadoop3.2.1 单机伪分布集群安装 一.准备环境： 1台 linux 虚拟机(Centos7.x 64 位)\n ip 为：192.168.2.100 hostname 为：hadoop100  虚拟机基本环境配置： 集群用到的所有机器都参考此流程进行配置。\n1.主机名设置 建议把此机器的主机名设置为 hadoop100 主机名的设置可以分为临时设置和永久设置。 临时设置可以立刻生效，但是不能永久保存，虚拟机重启后就会失效，所以建议永久设置。\n临时设置主机名\n[root@hadoop100 ~]# hostname hadoop100 永久设置主机名\n[root@hadoop100 ~]# vi /etc/sysconfig/network NETWORKING=yes HOSTNAME=hadoop100 2.hosts 文件配置 修改/etc/hosts 文件，把 ip 和 hostname 的映射关系配置进去，此处的 ip 需要和你设置的虚拟机实际 ip 相同\n[root@hadoop100 ~]# vi /etc/hosts 192.168.2.100 hadoop100 3.关闭防火墙 防火墙的关闭也分为临时关闭和永久关闭。 临时关闭可以立刻生效，但是不能永久保存，虚拟机重启后就会失效，所以建议永久设置。\n 临时关闭防火墙  [root@hadoop100 ~]# service iptables stop iptables: Setting chains to policy ACCEPT: filter [ OK ] iptables: Flushing firewall rules: [ OK ] iptables: Unloading modules: [ OK ]  永久关闭防火墙  [root@hadoop100 soft]# chkconfig iptables off  配置ssh 免密码登陆 配置 ssh 免密码登陆，在这里先实现免密码登陆本机 生成公钥，注意：执行这个命令以后，需要连续按 4 次回车键回到 linux 命令行才表示这个操作执行结束，在按回车的时候不需要输入任何内容。  [root@hadoop100 ~]# ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: 20:d0:89:24:29:1e:c8:50:b3:fb:e0:57:76:94:0c:ea root@hadoop100 The key\u0026#39;s randomart image is: +--[ RSA 2048]----+ |*+=o .. | |++.+o. o . | |o o o . + | | . o . o | | o E o S | | . o o . | | . o | | . | | | +-----------------+  向本机复制公钥  [root@hadoop100 ~]# cat ~/.ssh/id_rsa.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys  执行 ssh 命令验证免密码登陆是否配置成功，第一次验证的时候会提示输入 yes 或 no，直接输入 yes 即可，如果输入了 yes 之后按回车可以进入就表示免密码登陆配置成功。  [root@hadoop100 ~]# ssh hadoop100 The authenticity of host \u0026#39;hadoop100(192.168.111.100)\u0026#39; can\u0026#39;t be established. RSA key fingerprint is 64:87:b9:da:46:c1:85:54:49:6d:65:4a:0f:49:8f:58. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added \u0026#39;hadoop100\u0026#39; (RSA) to the list of known hosts. Last login: Thu Jul 25 09:11:46 2019 from hadoop100 4.jdk 安装 注意：在这里建议安装 jdk1.8 版本，jdk-8u181-linux-x64.tar.gz 上传 jdk 安装包到 linux 的/data/soft 目录，如果此目录不存在则提前创建\n[root@hadoop100 ~]# mkdir -p /data/soft/ [root@hadoop100 ~]# cd /data/soft/ 解压 jdk\n[root@hadoop100 soft]# tar -zxvf jdk-8u181-linux-x64.tar.gz 重命名\n[root@hadoop100 soft]# mv jdk1.8.0_181/ jdk1.8 配置 java 的环境变量，修改/etc/profile 文件，在文件末尾增加下面三行配置\n[root@hadoop100 soft]# vi /etc/profile export JAVA_HOME=/data/soft/jdk1.8 export HADOOP_HOME=/data/soft/hadoop-3.2.0 export PATH=.:$JAVA_HOME/bin:$HADOOP_HOME/bin:$PATH 验证环境变量配置是否成功，执行以下命令能看到输入信息即说明配置成功\n[root@hadoop100 soft]# java -version java version \u0026#34;1.8.0_181\u0026#34; Java(TM) SE Runtime Environment (build 1.8.0_181-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) 二.Hadoop 伪分布集群安装： 下面开始在 1 台 linux 虚拟机上开始安装 Hadoop3 伪分布环境 在这里我们使用 hadoop3.2.1 版本\n1.把 hadoop-3.2.1.tar.gz 安装包上传到 linux 机器的/data/soft 目录下 2.解压 hadoop 安装包 [root@hadoop100 ~]# cd /data/soft [root@hadoop100 soft]# tar -zxvf hadoop-3.2.1.tar.gz 3.修改 hadoop 相关配置文件 进入配置文件所在目录 [root@hadoop100 soft]# cd hadoop-3.2.1/etc/hadoop/\n 首先修改 hadoop-env.sh 文件，增加环境变量信息 [root@hadoop100 hadoop]# vi hadoop-env.sh  export JAVA_HOME=/data/soft/jdk1.8 export HADOOP_LOG_DIR=/data/hadoop_repo/logs/hadoop  修改 core-site.xml 文件，注意 fs.defaultFS 属性中的主机名需要和你配置的主机名保持一致 [root@hadoop100 hadoop]# vi core-site.xml  \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;hdfs://hadoop100:9000\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;hadoop.tmp.dir\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;/data/hadoop_repo\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt;  修改 hdfs-site.xml 文件，把 hdfs 中文件副本的数量设置为 1，因为现在伪分布集群只有一个节点 [root@hadoop100 hadoop]# vi hdfs-site.xml  \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;dfs.replication\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt;  修改 mapred-site.xml，设置 mapreduce 使用的资源调度框架为yarn  [root@hadoop100 hadoop]# vi mapred-site.xml \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.framework.name\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;yarn\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.app.mapreduce.am.env\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;HADOOP_MAPRED_HOME=/data/soft/hadoop-3.2.1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.map.env\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;HADOOP_MAPRED_HOME=/data/soft/hadoop-3.2.1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;mapreduce.reduce.env\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;HADOOP_MAPRED_HOME=/data/soft/hadoop-3.2.1\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt;  修改 yarn-site.xml，设置 yarn 上支持运行的服务和环境变量白名单  [root@hadoop100 hadoop]# vi yarn-site.xml \u0026lt;configuration\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.aux-services\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;mapreduce_shuffle\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;yarn.nodemanager.env-whitelist\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CL ASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/configuration\u0026gt; 4.格式化 namenode [root@hadoop100 hadoop]# cd /data/soft/hadoop-3.2.1 [root@hadoop100 hadoop-3.2.1]# bin/hdfs namenode -format 如果在后面的日志信息中能看到这一行，则说明 namenode 格式化成功。\ncommon.Storage: Storage directory /data/hadoop_repo/dfs/name has been successfully formatted. 5.修改脚本  修改start-dfs.sh，stop-dfs.sh 这两个脚本文件，在文件前面增加如下内容  [root@hadoop100 hadoop]# cd /data/soft/hadoop-3.2.1/sbin [root@hadoop100 sbin]# vi start-dfs.sh HDFS_DATANODE_USER=root HDFS_DATANODE_SECURE_USER=hdfs HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root [root@hadoop100 sbin]# vi stop-dfs.sh HDFS_DATANODE_USER=root HDFS_DATANODE_SECURE_USER=hdfs HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root  修改 start-yarn.sh，stop-yarn.sh 这两个脚本文件，在文件前面增加如下内容  [root@hadoop100 sbin]# vi start-yarn.sh YARN_RESOURCEMANAGER_USER=root HADOOP_SECURE_DN_USER=yarn YARN_NODEMANAGER_USER=root [root@hadoop100 sbin]# vi stop-yarn.sh YARN_RESOURCEMANAGER_USER=root HADOOP_SECURE_DN_USER=yarn YARN_NODEMANAGER_USER=root 6.再启动hadoop 集群 [root@hadoop100 hadoop-3.2.1]# sbin/start-all.sh Starting namenodes on [hadoop100] Starting datanodes Starting secondary namenodes [hadoop100] Starting resourcemanager Starting nodemanagers 验证集群进程信息 执行 jps 命令可以查看集群的进程信息，有以下进程才说明集群是正常启动的\n[root@hadoop100 sbin]# jps 2882 ResourceManager 2420 DataNode 3365 Jps 2619 SecondaryNameNode 2315 NameNode 2988 NodeManager 还可以通过 webui 界面来验证集群服务是否正常\n hdfs webui 界面：http://192.168.2.100:9870 yarn webui界面：http://192.168.2.100:8088\n 7.停止集群 如果修改了集群的配置文件或者是其它原因要停止集群，可以使用下面命令。\n[root@hadoop100 sbin]# ./stop-all.sh ","permalink":"https://trumpzhang.github.io/blog/hadoop/1.hadoop3.2.1%E5%8D%95%E6%9C%BA%E4%BC%AA%E5%88%86%E5%B8%83%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85/","tags":["Hadoop"],"title":"1.Hadoop3.2单机伪分布集群安装"},{"categories":["Spring Cloud"],"contents":"1.什么是Feign Feign是一个声明式的Web Service客户端，它的目的就是让Web Service调用更加简单。Feign提供了Http请求的模板，通过编写简单的接口和插入注解，就可以定义好Http请求的参数、格式、地址等信息。而Feign则会完全代理Http请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关处理，这使得我们调用Http API更加优雅。 Feign整合了Ribbon和Hystrix，从而让Feign的使用更加方便。 2.Feign的特性\n 可插拔的注解支持，包括Feign注解和JAX-RS注解; 支持可插拔的HTTP编码器和解码器; 支持Hystrix和它的Fallback; 支持Ribbon的负载均衡; 支持HTTP请求和响应的压缩。  这看起来有点像我们springmvc模式的Controller层的RequestMapping映射。这种模式是我们非常喜欢的。Feign是用@FeignClient来映射服务的。 Feign是以接口方式进行调用,而不是通过RestTemplate来调用,feign底层还是ribbon,并进行了封装,让我们调用起来更加方便。\n3.使用Feign 对消费者服务进行改造\n 引入坐标  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  application.yml  Feign默认不开启hystrix熔断，手动开启\nserver: port: 8081 spring: application: name: service-consumer eureka: client: service-url: defaultZone: http://localhost:9000/eureka,http://localhost:9001/eureka #多个地址用,号隔开 feign: hystrix: enabled: true #开启熔断功能  配置启动类  加上@EnableFeignClients注解（启用Feign组件）\n 建立FeignClient接口类 使用Feign非常简单，创建一个接口，并在接口上添加一些注解。  UserClient.java\n@FeignClient(value = \u0026#34;service-provider\u0026#34;,fallback = UserClientFallback.class)//调用微服务的id public interface UserClient { //和controller里的请求路径、入参一致  @GetMapping(\u0026#34;user/get/{id}\u0026#34;) public User queryUserById(@PathVariable int id); } UserClientFallback.java\n@Component public class UserClientFallback implements UserClient { @Override public User queryUserById(int id) { User user = new User(); user.setName(\u0026#34;服务器忙，稍后再试\u0026#34;); return user; } } User.java\npackage com.pojo; public class User { private Integer id; private String name; //省略setter和getter..... } UserController.java\n@RestController public class UserController { @Autowired private UserClient userClient; @GetMapping(\u0026#34;user/get/{id}\u0026#34;) @HystrixCommand public User queryUserById(@PathVariable int id){ return this.userClient.queryUserById(id); } } 访问\n http://localhost:8081/user/get/1\n 结果： ","permalink":"https://trumpzhang.github.io/blog/springcloud/feign/","tags":["Feign","Spring Cloud"],"title":"Feign"},{"categories":["Spring Cloud"],"contents":"1.为什么需要断路器 1.1存在问题 在理想状态下，一个应用依赖的服务都是健康可用的，我们可以正常处理所有的请求。默认情况下tomcat只有一个线程池去处理的客户端发送的所有服务请求，这样在高并发情况下，如果客户端所有的请求堆积到同一个服务接口上，就会产生tomcat的所有线程池去处理该服务接口，可能会导致其他服务奔溃。 1.2简介 Hystrix，英文意思是豪猪，全身是刺，看起来就不好惹，是一种保护机制。 Hystrix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。 1.3雪崩效应 在复杂的微服务架构中的应用程序有很多的依赖，都会不可避免地在某些时候失败。高并发的依赖失败时如果没有隔离措施，当前应用服务就有被拖垮的风险。一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路： 如图，一次业务请求，需要调用A、H、I、P四个服务，这四个服务又可能调用其它服务。 如果此时某个服务出现异常： 例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞： 服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务不可用，形成雪崩效应。 Hystrix解决雪崩问题的手段包括：\n 线程隔离 服务熔断 服务降级  1.4 解决方法和原理 （1）线程隔离 资源隔离（限流）：包括线程池隔离和信号量隔离，限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用。\n 线程池隔离模式：使用一个线程池来存储当前请求，线程池对请求作处理，设置任务返回处理超时时间，堆积的请求先入线程池队列。这种方式要为每个依赖服务申请线程池，有一定的资源消耗，好处是可以应对突发流量（流量洪峰来临时，处理不完可将数据存储到线程池队里慢慢处理） 信号量隔离模式：使用一个原子计数器（或信号量）记录当前有多少个线程在运行，请求来先判断计数器的数值，若超过设置的最大线程个数则丢弃该类型的新请求，若不超过则执行计数操作请求来计数器+1，请求返回计数器-1。这种方式是严格的控制线程且立即返回模式，无法应对突发流量（流量洪峰来临时，处理的线程超过数量，其他的请求会直接返回，不继续去请求依赖的服务）  （2）服务熔断 正常情况下，断路器处于关闭状态(Closed)，如果调用持续出错或者超时，电路被打开进入熔断状态(Open)，后续一段时间内的所有调用都会被拒绝(Fail Fast)，一段时间以后，保护器会尝试进入半熔断状态(Half-Open)，允许少量请求进来尝试，如果调用仍然失败，则回到熔断状态；如果调用成功，则回到电路闭合状态; Hystrix提供了如下的几个关键参数，来对一个熔断器进行配置：\n circuitBreaker.requestVolumeThreshold //滑动窗口的大小，默认为20 circuitBreaker.sleepWindowInMilliseconds //过多长时间，熔断器再次检测是否开启，默认为5000，即5s circuitBreaker.errorThresholdPercentage //错误率，默认50%  3个参数放在一起，所表达的意思就是： 每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会直接返回失败，不再调远程服务。直到5s之后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开。 熔断的3个状态：\n Closed:关闭状态，所有请求都正常访问 Open：打开状态，所有请求都会被降级。Hystrix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全打开。 Half Open：半开状态，open状态不是永久的，打开后会进入休眠时间（默认5s）。随后断路器会自动进入半开状态，此时会释放部分请求通过，若这些请求都是健康的，则会完全关闭断路器，否则继续保持打开，再次进行休眠计时。  （3）服务降级 服务降级：优先保证核心服务，而非核心服务不可用或弱可用。 例如：当用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统奔溃，至少可以看到一个执行结果（例如返回友好的提示信息），服务降级虽然会导致请求失败，但是不会导致阻塞，且对其它服务无响应。 触发Hystrix服务降级的情况：\n 线程池已满 请求超时  1.5 Hystrix使用 在服务消费方使用Hystrix\n 引入坐标  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  application.yml  在这里插入代码片  配置启动类  @EnableCircuitBreaker public class ServiceConsumerApplication { public static void main(String[] args) { SpringApplication.run(ServiceConsumerApplication.class, args); } }  为可能发生熔断的方法添加@HystrixCommand注解  @RestController @RequestMapping(\u0026#34;user\u0026#34;) //定义全局的熔断方法 @DefaultProperties(defaultFallback = \u0026#34;queryUserByIdFallBack\u0026#34;) public class UserController { @GetMapping(\u0026#34;get/{id}\u0026#34;) @HystrixCommand public String queryUserById(@PathVariable Long id){ return \u0026#34;请求的id:\u0026#34;+id; } public String queryUserByIdFallBack(Long id){ return \u0026#34;服务忙，稍后再试\u0026#34;; } } 这样当user/get/{id}请求调用的远程服务不可用时，将返回fallBack回调函数的内容。 1.6设置超时 Hystrix设置的默认超时时长为1，请求在超过1秒后会返回错误信息，可以通过配置信息修改时长\nhystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 6000 #超时时间 ","permalink":"https://trumpzhang.github.io/blog/springcloud/3.hystrix%E6%96%AD%E8%B7%AF%E5%99%A8/","tags":["Hystrix","Spring Cloud"],"title":"3.Hystrix"},{"categories":["Spring Cloud"],"contents":"Eureka高可用集群搭建 1.为什么需要集群 如果只有一个注册中心服务器，会存在单点故障所以要集群部署。这样即使集群中某个节点出现宕机等故障，系统仍可以从其他节点拉取微服务地址，从而正常运行。 2.集群搭建 生产环境把Eureka部署多个服务器就ok了,开发阶段可以使用同一台主机不同端口号来模拟集群：\n2.1 准备2个EurekaServer工程，需要相互注册 server1: 9000 server2: 9001\n EurekaServer1 application.yml  server: port: 9000 spring: application: name: eureka-server eureka: client: service-url: #注册到9001 defaultZone: http://localhost:9001/eureka  EurekaServer2 application.yml  server: port: 9001 spring: application: #name值一致 name: eureka-server eureka: client: service-url: #注册到9000 defaultZone: http://localhost:9000/eureka 访问相应的url地址 2.2 将微服务注册到EurekaServer集群 由于EurekaServer之间信息是同步的，所以只要微服务注册到一个节点上，那么集群中的每个节点都拥有该微服务的信息。 但若微服务注册的1个节点发生故障，则注册失败，为了保证高可用，需要将每个微服务注册到多个节点上。 (1)service-provider application.yml\nserver: port: 8081 spring: application: name: service-consumer eureka: client: service-url: defaultZone: http://localhost:9000/eureka,http://localhost:9001/eureka #多个地址用,号隔开 其他服务配置方法相同。\n","permalink":"https://trumpzhang.github.io/blog/springcloud/eureka%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/","tags":["Eureka","Spring Cloud"],"title":"2.1Eureka高可用集群搭建"},{"categories":["Spring Cloud"],"contents":"2.1 微服务的注册中心\n注册中心相当于微服务架构中的“通讯录”，它记录了服务和服务地址的映射关系，在分布式架构中，服务会注册到这里，当服务需要调用其他服务时，就在这里找到服务的地址进行调用。\n2.1.1 注册中心的主要作用\n服务注册中心是微服务架构中非常重要的一个组件，在微服务架构里主要起到了协调者的一个作用，注册中心一般包含如下几个功能：\n（1）服务发现\n 服务注册/反注册：保存服务提供者和服务调用者的信息 服务订阅/取消订阅：服务调用者订阅服务提供者的信息，最好有实时推送的功能 服务路由（可选）：具有筛选整合服务提供者的能力。  （2）服务配置\n 配置订阅：服务提供者和服务调用者订阅微服务相关的配置 配置下发：主动将配置推送给服务提供者和服务调用者  （3）服务健康检测\n 检测服务提供者的健康情况  2.1.2 常见的注册中心\n(1)Zookeeper\nZookeeper是一个分布式服务框架，是Apache Hadoop的一个子项目，主要是用来解决分布式应用中经常用到的一些数据管理问题，如：统一服务命名、状态同步服务、集群管理、分布式应用配置项的管理等，即Zookeeper=文件系统+监听通知机制。\n(2)Eureka\nEureka由Java语言开发，基于Restful API开发的服务注册与发现组件，Springcloud Netflix中的重要组件\n(3)Consul\nConsul是由HashiCorp基于Go语言开发的支持多数据中心分布式高可用的服务注册和服务发布软件，采用Raft算法保证服务的一致性，且支持健康检查。\n(4)Nacos\nNacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台，简单来说Nacos就是注册中心+配置中心的组合，提供简单易用的特性集，帮助我们解决微服务开发必会涉及到的服务注册与发现，服务配置，服务管理等问题。Nacos还是Spring Cloud Alibaba组件之一，负责服务注册与发现。\n上述注册中心的异同点：\n   组件名 语言 CAP 一致性算法 服务健康检查 对外暴露接口     Eureka Java AP 无 可配支持 Http   Consul go CP Raft 支持 Http/DNS   Zookeeper java CP Paxos 支持 客户端   Nacos java AP Raft 支持 Http    CAP原理\n    强调 作用     C 一致性 保持多节点数据一致   A 可用性 保持服务可用：多节点   P 分区容错性 将数据存到多个节点    不可能同时满足CAP:\n AC:放弃分区容错，物理数据库 AP:可以短暂允许数据不一致，NoSql数据库 CP:放弃可用性,zookeeper  2.2 Eureka概述\n2.2.1 Eureka的基础知识\nEureka是Netflix开发的服务发现框架，SpringCloud将它集成在自己的子项目spring-cloud-netflix中，实现SpringCloud的服务发现功能。 上图简要描述了Eureka的基本架构，由3个角色组成：\n Eureka Server   提供服务注册和发现  Service Provider   服务提供方 将自身服务注册到Eureka，从而使服务消费方能够找到  3.Service Consumer\n 服务消费方 从Eureka获取注册服务列表，从而能够消费服务  2.2.2 Eureka的交互流程与原理 2.3 使用Eureka\n(1)搭建eureka server\n 创建工程模块（使用Initializr）   导入坐标  \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;Hoxton.SR1\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!--eureka-server 依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt;  配置application.yml  server: port: 9000 spring: application: name: eureka-server eureka: instance: hostname: localhost client: service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka register-with-eureka: false #是否将自己注册到注册中心 fetch-registry: false #是否从eureka中获取注册信息  配置启动类  @SpringBootApplication //激活eureka server注册中心 @EnableEurekaServer public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class, args); } } (2)将服务提供者注册到eurekaServer上 搭建服务提供方 服务提供方的依赖：  引入坐标  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  配置application.yml  server: port: 8080 spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=true\u0026amp;serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver application: name: service-provider #作为微服务的名称 mybatis: type-aliases-package: com.pojo #配置eureka eureka: client: service-url: defaultZone: http://localhost:9000/eureka instance: prefer-ip-address: true #使用ip注册  配置启动类  加上@EnableDiscoveryClient或@EnableEurekaClient注解\n最新的SpringBoot可不配置注解\npublic class ServiceProviderApplication { public static void main(String[] args) { SpringApplication.run(ServiceProviderApplication.class, args); } } (3)服务消费者通过注册中心获取服务列表并调用 由于服务消费方只需要使用Restful接口，因此只需要勾选Spring Web组件即可。\n 引入坐标  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  配置yml文件  server: port: 8081 spring: application: name: service-consumer eureka: client: service-url: defaultZone: http://localhost:9000/eureka  配置启动类  @EnableDiscoveryClient public class ServiceConsumerApplication { public static void main(String[] args) { SpringApplication.run(ServiceConsumerApplication.class, args); } } (4)查看注册中心 访问 http://localhost:9000/ ","permalink":"https://trumpzhang.github.io/blog/springcloud/2.%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0eureka%E5%9F%BA%E7%A1%80/","tags":["Eureka","Spring Cloud"],"title":"2.服务注册与发现"},{"categories":["Spring Cloud"],"contents":"一、网站架构演变过程 网站架构大致可以分为以下几个阶段： 传统架构（单体应用）-\u0026gt;分布式架构（以项目进行拆分）-\u0026gt;SOA（面向服务架构）-\u0026gt;微服务架构\n1.Monolith（单体应用）架构 1.1\t什么是单体应用 首先请回想一下我们所开发的服务是什么样子的。通常情况下，这个服务所对应的代码由多个项目所组成，各个项目会根据自身所提供功能的不同具有一个明确的边界。在编译时，这些项目将被打包成为一个个JAR包，并最终合并在一起形成一个WAR包。接下来，我们需要将该WAR包上传到Web容器中，解压该WAR包，并重新启动服务器。在执行完这一系列操作之后，我们对服务的编译及部署就已经完成了。这种将所有的代码及功能都包含在一个WAR包中的项目组织方式被称为Monolith。例如我们使用的SSH、SSM架构都是单体架构。 1.2\t缺点 这种架构将整个业务模块在一个项目中进行开发，按照MVC思想分层。 在项目很小的情况下这种单体应用比较简单，但是随着项目越变越大，代码越来越多，就会存在以下缺点：\n 编译难，部署难，测试难 代码量变多，及时更改一行代码，也需花大量时间编译，部署前要编译打包，解压等所以部署难，部署完了还要测试所以测试难。 耦合度高 一旦某个模块导致服务不可用，可能会影响到整个项目。 扩展难 按照Monolith组织的代码将只产生一个包含了所有功能的WAR包，因此在对服务的容量进行扩展的时候，我们只能选择重复地部署这些WAR包来扩展服务能力，而不是仅仅扩展出现系统瓶颈的组成。  2.分布式架构 基于传统架构演变而来，将整个项目拆分为多个子项目，分为以下几个阶段： 2.1数据库服务、应用、文件分离阶段 2.2应用服务器集群部署阶段 当业务访问量很大的时候，用户的请求会进行排队等待，这导致了糟糕的用户体验，这个时候可以将同一个应用部署在多台服务器上，将大量的用户请求分发到各个服务器上，以缓解一台服务器的压力。 而怎么分发请求，这就涉及到负载均衡（Load Balancing）算法的设计，一个好的负载均衡算法可以将服务器性能最大化，常用的负载均衡算法有：\n 轮询法 轮询法，就是将用户的请求轮流分配给服务器，就像是挨个数数，轮流分配。这种算法比较简单，他具有绝对均衡的优点，但是也正是因为绝对均衡它必须付出很大的代价，例如它无法保证分配任务的合理性，无法根据服务器承受能力来分配任务。 随机法 随机法，是随机选择一台服务器来分配任务。它保证了请求的分散性达到了均衡的目的。同时它是没有状态的不需要维持上次的选择状态和均衡因子[5]。但是随着任务量的增大，它的效果趋向轮询后也会具有轮询算法的部分缺点。 最小连接法 最小连接法，将任务分配给此时具有最小连接数的节点，因此它是动态负载均衡算法。一个节点收到一个任务后连接数就会加1，当节点故障时就将节点权值设置为0，不再给节点分配任务。最小连接法适用于各个节点处理的性能相似时。任务分发单元会将任务平滑分配给服务器。但当服务器性能差距较大时，就无法达到预期的效果。因为此时连接数并不能准确表明处理能力，连接数小而自身性能很差的服务器可能不及连接数大而自身性能极好的服务器。所以在这个时候就会导致任务无法准确的分配到剩余处理能力强的机器上。  2.3数据库读写分离阶段 2.4为了缓解数据库压力，又在系统加入NoSql（Redis、MongoDB）等内存型数据库作为缓存 此时遇到用户请求，先去查找缓存，若查到则只需要1次内存I/O；缓存中没有时，经过1次磁盘I/O从数据库读取数据，再经过1次内存I/O写入缓存。 2.5将服务器集群按照应用拆分并拆分数据库 随着业务量的增加，表的数据不断增长，数据查询性能便成了问题，所以必须要对数据库进行水平拆分。水平拆分是将单个表的数据拆分到多个数据库中，如100W数据的表拆分到10个数据库后，每个表就只有10w。 3.SOA架构（Service-Oriented Architecture） 在上面的架构中，用户服务会调用到商品服务，商品服务又会调用交易服务，用户服务又调用订单服务，调用关系错综复杂，维护成本不断变高。此时，SOA架构出现了： SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。 SOA将能够帮助软件工程师们站在一个新的高度理解企业级架构中的各种组件的开发、部署形式，它将帮助企业系统架构者以更迅速、更可靠、更具重用性架构整个业务系统。较之以往，以SOA架构的系统能够更加从容地面对业务的急剧变化。\nSOA架构通俗的理解为将共同的业务逻辑抽取出来形成一个通用服务，如Mq、Hdfs、检索工具等，该服务作为一个独立项目部署，给其他服务提供接口进行调用，服务间调用依然使用RPC远程技术。 4.微服务架构 微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于Http的Restful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。 微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立开发,独立部署,独立运维，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。 4.1.那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下几种：\n RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。  由于微服务架构中存在多个微服务，那么如何管理和协调这些服务呢？就需要服务治理框架，而springcloud就是一个基于Spring Boot实现的服务治理工具包。 4.2. 什么是Spring Cloud Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Springcloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 以下是主要组成部分（摘自百度）： Spring Cloud有很多优秀组件，后面的文章会一一列举。\n","permalink":"https://trumpzhang.github.io/blog/springcloud/1.%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B%E7%AE%80%E8%BF%B0/","tags":["架构"],"title":"网站架构演变过程简述"},{"categories":["Spring Boot"],"contents":"前言： 使用SpringBoot很方便，但经常因为一个业务而写很多SQL语句（很多都是CRUD），而怎样才能不写SQL语句或很少写呢？ 最近发现了一款好玩的mybatis插件（通用Mapper）tk-mybatis，它解决了上面的这些问题。 介绍： tk-mybatis由国人编写，码云地址\n https://gitee.com/free\n 作者还写了使用文档，地址\n https://gitee.com/free/Mapper/wikis/Home\n 优点：\n 通用Mapper极大的方便开发人员 可以随意的按照自己的需要选择通用方法，还可以很方便的开发自己的通用方法 极其方便的使用MyBatis单表的增删改查 自动生成常用的增删改查的SQL语句 支持单表操作，不支持通用的多表联合查询。  比较： 与MPG插件（mybatis plus generator ）的比较：\n 使用MPG时：当数据库表的字段被人为修改后，需要重新使用MPG插件生成*.xml,而tk-mybatis解决了这个问题，它会根据表的字段信息动态修改，当你修改了数据库，不用操心要不要修改mapper。  一.SpringBoot集成tk-mybatis 与SpringBoot的集成，可分为以下几步：\n 添加tk-mybatis依赖  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;tk.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapper-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 注意：引入该 starter 时，和 MyBatis 官方的 starter 没有冲突，你不用担心已经依赖的mybatis版本，只需要加入上面的依赖即可，但是官方的自动配置不会生效！\n创建pojo、mapper、service、controller包，目录结构如下：   pojo-\u0026gt;User.java\n//指定表名 @Table(name = \u0026#34;user\u0026#34;) public class User { //表的主键  @Id @GeneratedValue(strategy = GenerationType.IDENTITY) //使用包装类  private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } mapper-\u0026gt;UserMapper.java\nimport org.springframework.stereotype.Repository; import tk.mybatis.mapper.common.Mapper; @Repository public interface UserMapper extends Mapper\u0026lt;User\u0026gt; { } service-\u0026gt;UserService.java\n@Service public class UserService { @Autowired private UserMapper userMapper; public User getUserById(int id){ //使用tk-mybatis提供的selectByPrimaryKey方法  return userMapper.selectByPrimaryKey(id); } public List\u0026lt;User\u0026gt; getAllUser(){ //使用tk-mybatis提供的selectAll方法  return userMapper.selectAll(); } } controller-\u0026gt;UserController.java\n@RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private UserService userService; @GetMapping(\u0026#34;get/{id}\u0026#34;) public User getUserById(@PathVariable int id){ return this.userService.getUserById(id);} @GetMapping(\u0026#34;getAll\u0026#34;) public List\u0026lt;User\u0026gt; getAll(){ return this.userService.getAllUser(); } } 在主类添加tk-mybatis的MapperScan扫描mapper  //注意是tk的MapperScan import tk.mybatis.spring.annotation.MapperScan; @SpringBootApplication //扫描mapper @MapperScan(\u0026#34;com.example.mapper\u0026#34;) public class Springbootdemo1Application { public static void main(String[] args) { SpringApplication.run(Springbootdemo1Application.class, args); } } 这样就好了，启动服务器请求数据：\n http://localhost:8080/user/get/1\n 结果：\n http://localhost:8080/user/getAll\n 结果： 二.tk-mybatis使用方法总结 1.实体类字段需使用包装类，不要使用基本数据类型 使用通用mapper进行查询的时候，如果对象中的属性类型不是包装类型，如int,long等，在查询的时候，没有作为条件查询，但执行的时候，仍然会拼接该字段进行查询，就会出现查不到数据的情况。因此，在建立实体类的时候，一定要用包装类型接收。 例如自增的id，要用Integer或者Long;如果用int或者long，在使用通用mapper查询时就会自动拼接id作为查询条件,从而拿不到数据。这是一个开发过程中可能遇到的坑。\n2.常用方法 查询 select |方法名 |作用 | |\u0026ndash;|\u0026ndash;| | List \u0026lt;T\u0026gt; selectAll();| 查询所有数据 | | T selectByPrimaryKey(Object key); | 通过主键查询单个数据| |T selectOne(T record); | 通过实体查询单个数据 | | List\u0026lt;T\u0026gt; select(T record); | 通过实体查询多个数据 | | int selectCount(T record);\t| 通过实体查询实体数量 | | boolean existsWithPrimaryKey(Object key); | 通过主键查询此实体是否存在| 其他常用的方法用到再列出，还可以去文档地址查看提供的方法。\n","permalink":"https://trumpzhang.github.io/blog/springboot/springboot%E9%9B%86%E6%88%90tk-mybatis%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/","tags":["Spring Boot","tk-mybatis"],"title":"SpringBoot集成tk Mybatis简单方法"},{"categories":["Spring Boot"],"contents":"SpringBoot学习笔记 1.简介 Spring Boot来简化Spring应用开发，约定大于配置， 去繁从简，just run就能创建一个独立的，产品级别的应用 背景： J2EE笨重的开发、繁多的配置、低下的开发效率、 复杂的部署流程、第三方技术集成难度大。 解决： “Spring全家桶”时代。 Spring Boot -\u0026gt;J2EE一站式解决方案 Spring Cloud -\u0026gt;分布式整体解决方案 优点：\n 快速创建独立运行的Spring项目以及与主流框架集成 使用嵌入式的Servlet容器，应用无需打成WAR包 starters自动依赖与版本控制 大量的自动配置，简化开发，也可修改默认值 – 无需配置XML，无代码生成，开箱即用 准生产环境的运行时应用监控 与云计算的天然集成  springBoot的最终奉行的宗旨：废除所有复杂的开发，废除掉所有的配置文件，让开发变得更简单纯粹。SpringBoot的核心就是“零配置”。\n2.Spring boot入门 2.1.\t开发环境 开发环境JDK 1.8+ 项目管理工具（ Maven3.x+ ） 开发工具(idea)\n2.2.\t入门 2.2.1. 创建Maven配置 在D盘创建好maven_config文件夹，里面再创建一个repository文件夹（用于存放maven下载的依赖包）和settings.xml（maven配置文件），后面会用到 其中settings.xml内容如下（使用阿里云镜像源）：\n\u0026lt;settings xmlns=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd\u0026#34;\u0026gt; \u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; \u0026lt;/settings\u0026gt; 2.2.2.\t使用Spring Initializr（Spring脚手架）新建一个名为springbootdemo1的项目 File-\u0026gt;New-\u0026gt;Project-\u0026gt;Spring Initializr Web-\u0026gt;Spring Web，点击Next 设置maven下载位置和配置文件为第一步的配置： File | Settings | Build, Execution, Deployment | Build Tools | Maven 确认后等待maven下载所需依赖，下载完后pom.xml内容如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springbootdemo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;springbootdemo\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 2.2.3.\t在example包下新建controller包，并在controller包下新建HelloController类，内容如下：\npackage com.example.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\u0026#34;hello\u0026#34;) public class HelloController { @RequestMapping(\u0026#34;first\u0026#34;) public String first(){ return \u0026#34;Hello SpringBoot\u0026#34;; } } 2.2.4.\t启动此类，浏览器访问\n http://localhost:8080/hello/first 发现可以访问到数据\n 2.2.5 文件结构 （1）pom文件结构\n\u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; 表示springBoot的父级依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; spring-boot-starter-xxx：spring-boot场景启动器，帮我们导入了所需模块正常运行所依赖的组件，比如web组件、单元测试组件。 Spring Boot将所有的功能场景都抽取出来，做成一个个的starter（启动器），只需要在项目里面引入这些starter，相关场景的所有依赖都会导入进来。需要什么功能就导入什么场景的启动器。\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 表示编译时候的一些配置，比如一些插件、打包相关都在此配置。\n（2）启动类（引导类）\npackage com.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class SpringbootdemoApplication { public static void main(String[] args) { SpringApplication.run(SpringbootdemoApplication.class, args); } } 通过@SpringBootApplication注解，声明一个启动类，由于SpringBoot内置了tomcat服务器，会将此项目部署在tomcat上。\n","permalink":"https://trumpzhang.github.io/blog/springboot/springboot%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","tags":["Spring Boot","yaml"],"title":"SpringBoot快速入门"},{"categories":["Spring Boot"],"contents":"springboot常用注解 @SpringBootApplication\n包含@Configuration、@EnableAutoConfiguration、@ComponentScan\n通常用在主类上。\n@Repository\n用于标注数据访问组件，即DAO组件。\n@Service\n用于标注业务层组件。\n@RestController\n用于标注控制层组件，相当于@Controller+@ResponseBody\n@ResponseBody\n表示该方法的返回结果直接写入HTTP response body中\n一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。\n@Component\n泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\n@ComponentScan\n组件扫描。相当于context:component-scan，如果扫描到有@Component @Controller @Service等这些注解的类，则把这些类注册为bean。\n@Configuration\n指出该类是 Bean 配置的信息源，相当于XML中的，一般加在主类上。\n@Bean\n相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。\n@EnableAutoConfiguration\n让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上。\n@AutoWired\nbyType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 当加上（required=false）时，就算找不到bean也不报错。\n@Qualifier\n当有多个同一类型的Bean时，可以用@Qualifier(\u0026ldquo;name\u0026rdquo;)来指定。与@Autowired配合使用\n@Resource(name=\u0026quot;name\u0026rdquo;,type=\u0026quot;type\u0026rdquo;)\n没有括号内内容的话，默认byName。与@Autowired干类似的事。\n@RequestMapping\nRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n该注解有六个属性：\nparams:指定request中必须包含某些参数值是，才让该方法处理。\nheaders:指定request中必须包含某些指定的header值，才能让该方法处理请求。\nvalue:指定请求的实际地址，指定的地址可以是URI Template 模式\nmethod:指定请求的method类型， GET、POST、PUT、DELETE等\nconsumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;\nproduces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回\n@RequestParam\n用在方法的参数前面。\n@RequestParam String a =request.getParameter(\u0026ldquo;a\u0026rdquo;)\n@PathVariable\n路径变量。参数与大括号里的名字一样要相同。\nRequestMapping(\u0026ldquo;user/get/mac/{macAddress}\u0026quot;)\npublic String getByMacAddress(@PathVariable String macAddress){\n　//do something;\n　}\n@Profiles\nSpring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只能在特定的环境下生效。\n任何@Component或@Configuration都能被@Profile标记，从而限制加载它的时机。 @Configuration @Profile(\u0026ldquo;prod\u0026rdquo;) public class ProductionConfiguration { // \u0026hellip;}\n@ConfigurationProperties\nSpring Boot将尝试校验外部的配置，默认使用JSR-303（如果在classpath路径中）。 你可以轻松的为你的@ConfigurationProperties类添加JSR-303 javax.validation约束注解：\n@Component\n@ConfigurationProperties(prefix=\u0026quot;connection\u0026rdquo;)\npublic class ConnectionSettings {\n@NotNullprivate InetAddress remoteAddress;\n// \u0026hellip; getters and setters\n}\n全局异常处理\n@ControllerAdvice\n包含@Component。可以被扫描到。\n统一处理异常\n@ExceptionHandler（Exception.class）：\n用在方法上面表示遇到这个异常就执行以下方法。\n","permalink":"https://trumpzhang.github.io/blog/springboot/springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/","tags":["Spring Boot","yaml"],"title":"SpringBoot常用注解"},{"categories":["Spring Boot"],"contents":"1.YAML Springboot除了支持properties的配置，还支持yaml，而且企业中也是用的最多的。 1.1.\tYAML 是什么 YAML（/ˈjæməl/，尾音类似camel骆驼）是一个可读性高，用来表达数据序列化的格式。YAML参考了其他多种语言，包括：C语言、Python、Perl，并从XML、电子邮件的数据格式（RFC 2822）中获得灵感。Clark Evans在2001年首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者。当前已经有数种编程语言或脚本语言支持（或者说解析）这种语言。 YAML是\u0026quot;YAML Ain\u0026rsquo;t a Markup Language\u0026rdquo;（YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\u0026ldquo;Yet Another Markup Language\u0026rdquo;（仍是一种标记语言），但为了强调这种语言以数据做为中心，而不是以标记语言为重点，而用反向缩略语重命名。 1.2\t原则与语法 原则：\n 大小写敏感 使用缩进表示层级关系 缩进长度没有限制，只要元素对齐就表示这些元素属于一个层级。 使用#表示注释 字符串可以不用引号标注  语法：\n map,散列表 使用冒号：表示键值对，同一缩进的所有键值对属于一个map，示例：  age : 12 name : zhang #对应的Json表示 {‘age\u0026#39;:12,\u0026#39;name\u0026#39;:\u0026#39;zhang\u0026#39;}  list，数组 使用连字符（-）表示：  - a - b - 12 #对应的Json表示 [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,12]  相互嵌套  - id: 1 name: zhang - id: 2 name: liu #对应的Json表示 [{id: 1,name: \u0026#39;zhang\u0026#39;},{id: 2,name: \u0026#39;liu\u0026#39;}] 1.3\t使用场景\n 脚本语言 由于实现简单，解析成本很低，YAML特别适合在脚本语言中使用。列一下现有的语言实现：Ruby，Java，Perl，Python，PHP，OCaml，JavaScript，Go 。除了Java 和 Go，其他都是脚本语言。 序列化 YAML比较适合做序列化。因为它是宿主语言数据类型直转的。 配置文件 YAML做配置文件也不错。写YAML要比写XML快得多(无需关注标签或引号)，并且比ini文档功能更强。 比如Ruby on Rails的配置就选用的YAML。对ROR而言，这很自然，也很省事. 由于兼容性问题，不同语言间的数据流转建议不要用YAML.  1.4\t与XML比较 （1）安全性 YAML是纯粹用来表达资料的语言，所以内部不会存代码注入的可执行命令。这代表剖析器会相当（至少）安全的解析文件，而不用担心潜在与执行命令相关的安全漏洞。举例来说，JSON是JavaScript的子集，使用JavaScript本身的剖析器是相当诱人的，不过也造成许多代码注入的漏洞。虽然在所有资料序列语言中，安全解析本质上是可能的，但可执行性却正是这样一个恶名昭彰的缺陷；而YAML缺乏相关的命令语言，可能相对安全。\n2.SpringBoot多环境 Spring官方建议使用yaml文件做配置文件，在实际项目中，我们会有多个环境例如：开发，准生产，生产，测试，产品等。 Spring Profiles提供了一种隔离应用程序配置的方式，并让这些配置只在特定的环境下生效。 2.1 多环境 我们在主配置文件编写的时候，文件名可以是 application-{profile}.yml 默认使用application.yml的配置。 比如我们可以建立如下配置文件： application-dev.yml 开发环境 application-prod.yml 生产环境 application-test.yml 测试环境 要使用开发环境，则在application.yml中使用spring.profiles.active激活dev环境即可：\napplication.yml\nspring: profiles: active: dev application-dev.yml\nserver: port: 8080 #添加需要的配置 ","permalink":"https://trumpzhang.github.io/blog/springboot/yaml%E4%B8%8Espringboot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","tags":["Spring Boot","yaml"],"title":"YAML与SpringBoot多环境配置"},{"categories":["Spring Boot"],"contents":"RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。RESTFUL适用于移动互联网厂商作为业务使能接口的场景，实现第三方OTT调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。 REST（英文：Representational State Transfer，简称REST）描述了一个架构样式的网络系统，比如 web 应用程序。 在目前主流的三种Web服务交互方案中，REST相比于SOAP（Simple Object Access protocol，简单对象访问协议）以及XML-RPC更加简单明了，无论是对URL的处理还是对Payload的编码，REST都倾向于用更加简单轻量的方法设计和实现。值得注意的是REST并没有一个明确的标准，而更像是一种设计的风格。\n 原则条件 REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。 Web 应用程序最重要的 REST 原则是，客户端和服务器之间的交互在请求之间是无状态的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合云计算之类的环境。客户端可以缓存数据以改进性能。 在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 URI (Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、PUT、POST 和 DELETE。 特点 RESTFUL特点包括： 1、每一个URI代表1种资源； 2、客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源； 3、通过操作资源的表现形式来操作资源； 4、资源的表现形式是XML或者HTML； 5、客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。 RESTful与 RPC 在 REST 样式的 Web 服务中，每个资源都有一个地址。资源本身都是方法调用的目标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、POST、PUT、DELETE 在 RPC 样式的架构中，关注点在于方法，而在 REST 样式的架构中，关注点在于资源 —— 将使用标准方法检索并操作信息片段（使用表示的形式）。资源表示形式在表示形式中使用超链接互联。 RESTful架构 RESTful架构是对MVC架构改进后所形成的一种架构，通过使用事先定义好的接口与不同的服务联系起来。在RESTful架构中，浏览器使用POST，DELETE，PUT和GET四种请求方式分别对指定的URL资源进行增删改查操作。因此，RESTful是通过URI实现对资源的管理及访问，具有扩展性强、结构清晰的特点。 RESTful架构将服务器分成前端服务器和后端服务器两部分，前端服务器为用户提供无模型的视图；后端服务器为前端服务器提供接口。浏览器向前端服务器请求视图，通过视图中包含的AJAX函数发起接口请求获取模型。 优势 项目开发引入RESTful架构，利于团队并行开发。在RESTful架构中，将多数HTTP请求转移到前端服务器上，降低服务器的负荷，使视图获取后端模型失败也能呈现。但RESTful架构却不适用于所有的项目，当项目比较小时无需使用RESTful架构，项目变得更加复杂。  ","permalink":"https://trumpzhang.github.io/blog/springboot/restfulapi/","tags":["RestfulAPI"],"title":"RestfulAPI"},{"categories":["Spring Boot"],"contents":"1.SpringBoot整合Mybatis  File| New|Project |Spring Initializr|  选择需要的组件：  配置Maven:  修改配置文件  application.yml\nspring: profiles: active: dev application.yml-dev\nserver: port: 8080 spring: datasource: username: root password: 123456 url: jdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=true\u0026amp;serverTimezone=UTC driver-class-name: com.mysql.cj.jdbc.Driver mybatis: # 让mybatis自动扫描到自定义POJO type-aliases-package: com.example.pojo  test数据库建立user表并添加数据测试：  id int 20 primarykey name varchar 20  在com.example下建立pojo、mapper、service、controller包 pojo-\u0026gt;User.java  package com.example.pojo; public class User { int id; String name; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } mapper-\u0026gt;UserMapper.java\npackage com.example.mapper; import com.example.pojo.User; import org.apache.ibatis.annotations.Param; import org.apache.ibatis.annotations.Select; import org.springframework.stereotype.Repository; @Repository public interface UserMapper { @Select(\u0026#34;select * from user where id=#{id}\u0026#34;) User getUserById(@Param(\u0026#34;id\u0026#34;) int id); } service-\u0026gt;UserService.java\npackage com.example.service; import com.example.mapper.UserMapper; import com.example.pojo.User; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; @Service public class UserService { @Autowired private UserMapper userMapper; public User getUserById(int id){ return userMapper.getUserById(id); } } controller-\u0026gt;UserController.java\npackage com.example.controller; import com.example.pojo.User; import com.example.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private UserService userService; @GetMapping(\u0026#34;get/{id}\u0026#34;) public User getUserById(@PathVariable int id){ return this.userService.getUserById(id);} }  编写启动类：Springbootdemo1Application.java  package com.example; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication //扫描mapper @MapperScan(\u0026#34;com.example.mapper\u0026#34;) public class Springbootdemo1Application { public static void main(String[] args) { SpringApplication.run(Springbootdemo1Application.class, args); } } 此时，启动服务器，访问\n http://localhost:8080/user/get/1\n 结果如下： 关于SpringBoot整合Mybatis的其他方法后面会继续补充。\n","permalink":"https://trumpzhang.github.io/blog/springboot/springboot%E6%95%B4%E5%90%88mybatis/","tags":["Spring Boot","Java","mybatis"],"title":"SpringBoot整合Mybatis"},{"categories":["vue"],"contents":"1.封装子组件时  首先对子组件需要的的数据进行整理 子组件名称使用 - 区别，使用div等标签包裹子组件模板内容 子组件的style文件加上scoped作用域 子组件添加props、data、methods等属性，数据由父组件传入子组件 子组件具体的事件处理逻辑应在父组件实现，因此在子组件使用this.$emit('inChange',index) 表示父组件监听 inChange事件，将index传至父组件，让父组件实现具体的事件处理逻辑  2.父组件引入子组件时  引入的组件名称使用驼峰，不能有 - ，使用:item :index等传入子组件所需数据 父组件使用@inChange=\u0026quot;inChange\u0026quot;来实现处理逻辑，注意此处inChange后参数index可有可无，而在实现inChange函数时需要子组件传过来的参数index  3.一个简单的例子 子组件child.vue\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;child\u0026#34;\u0026gt; \u0026lt;v-switch v-model=\u0026#34;item.in_switch\u0026#34; :label=\u0026#34;item.in_switch? \u0026#39;on\u0026#39;:\u0026#39;off\u0026#39; \u0026#34; @change=\u0026#34;inChange(index)\u0026#34;\u0026gt;\u0026lt;/v-switch\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props:{ item: Object, index: Number }, methods:{ inChange(index){ // 父组件监听 inChange事件，将index传过去，将处理逻辑放在父组件  this.$emit(\u0026#34;inChange\u0026#34;,index); } } } \u0026lt;/script\u0026gt; 父组件parent.vue\n\u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;parent\u0026#34;\u0026gt; // 注意这里inChange的参数可有可无 \t\u0026lt;child :item=\u0026#34;item\u0026#34; :index=\u0026#34;index\u0026#34; @inChange=\u0026#34;inChange\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // @ is an alias to /src import child from \u0026#34;../child\u0026#34;; export default { components: { child }, data() { return { item: { in_switch: true, }, index: 0 } }, methods:{ // inchange事件处理，有index参数  inChange(index){ console.log( index) }, } } \u0026lt;/script\u0026gt; ","permalink":"https://trumpzhang.github.io/blog/vue/vue%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%E5%8F%8A%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","tags":["vue"],"title":"Vue组件封装及父、子组件通信"}]